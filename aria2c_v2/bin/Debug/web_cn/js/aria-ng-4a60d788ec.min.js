/*!
 * AriaNg
 * https://github.com/mayswind/AriaNg
 */
!function () {
	"use strict";
	if (function () {
		var e = navigator.appName,
		t = navigator.appVersion.split(";"),
		a = t && t.length > 1 ? t[1].replace(/[ ]/g, "") : "";
		return "Microsoft Internet Explorer" === e && ("MSIE6.0" === a || "MSIE7.0" === a || "MSIE8.0" === a || "MSIE9.0" === a)
	}
		()) {
		var e = document.createElement("div");
		e.className = "alert alert-danger",
		e.innerHTML = "Sorry, AriaNg cannot support this browser, please upgrade your browser!",
		document.getElementById("content-wrapper").appendChild(e)
	}
}
(), function () {
	"use strict";
	$.AdminLTE.options.animationSpeed = 300
}
(), function () {
	"use strict";
	var e = function () {
		var e = $(window).height(),
		t = $(".main-header").outerHeight() + $(".main-footer").outerHeight();
		$(".content-body").css("height", e - t)
	};
	$(window, ".wrapper").resize(function () {
		e()
	}),
	e()
}
(), function () {
	"use strict";
	angular.module("ariaNg", ["ngRoute", "ngSanitize", "ngTouch", "ngMessages", "ngCookies", "ngAnimate", "pascalprecht.translate", "angularMoment", "ngWebSocket", "ab-base64", "LocalStorageModule", "notification", "ui-notification", "angularBittorrentPeerid", "cgBusy", "angularPromiseButtons", "oitozero.ngSweetAlert", angularDragula(angular)])
}
(), function () {
	"use strict";
	angular.module("ariaNg").config(["$routeProvider", function (e) {
				e.when("/downloading", {
					templateUrl: "views/list.html",
					controller: "DownloadListController"
				}).when("/waiting", {
					templateUrl: "views/list.html",
					controller: "DownloadListController"
				}).when("/stopped", {
					templateUrl: "views/list.html",
					controller: "DownloadListController"
				}).when("/new", {
					templateUrl: "views/new.html",
					controller: "NewTaskController"
				}).when("/new/:url", {
					template: "",
					controller: "CommandController"
				}).when("/task/detail/:gid", {
					templateUrl: "views/task-detail.html",
					controller: "TaskDetailController"
				}).when("/settings/ariang", {
					templateUrl: "views/settings-ariang.html",
					controller: "AriaNgSettingsController"
				}).when("/settings/ariang/:extendType", {
					templateUrl: "views/settings-ariang.html",
					controller: "AriaNgSettingsController"
				}).when("/settings/aria2/basic", {
					templateUrl: "views/settings-aria2.html",
					controller: "Aria2SettingsController"
				}).when("/settings/aria2/http-ftp-sftp", {
					templateUrl: "views/settings-aria2.html",
					controller: "Aria2SettingsController"
				}).when("/settings/aria2/http", {
					templateUrl: "views/settings-aria2.html",
					controller: "Aria2SettingsController"
				}).when("/settings/aria2/ftp-sftp", {
					templateUrl: "views/settings-aria2.html",
					controller: "Aria2SettingsController"
				}).when("/settings/aria2/bt", {
					templateUrl: "views/settings-aria2.html",
					controller: "Aria2SettingsController"
				}).when("/settings/aria2/metalink", {
					templateUrl: "views/settings-aria2.html",
					controller: "Aria2SettingsController"
				}).when("/settings/aria2/rpc", {
					templateUrl: "views/settings-aria2.html",
					controller: "Aria2SettingsController"
				}).when("/settings/aria2/advanced", {
					templateUrl: "views/settings-aria2.html",
					controller: "Aria2SettingsController"
				}).when("/settings/rpc/set/:protocol/:host/:port/:interface/:secret?", {
					template: "",
					controller: "CommandController"
				}).when("/status", {
					templateUrl: "views/status.html",
					controller: "Aria2StatusController"
				}).otherwise({
					redirectTo: "/downloading"
				})
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").run(["$rootScope", "$location", "$document", "SweetAlert", "ariaNgNotificationService", "ariaNgSettingService", "aria2TaskService", function (e, t, a, n, i, s, o) {
				var r = function (e, t) {
					return e === t || 0 === t.indexOf(e) && 0 === t.substring(e.length).indexOf("/")
				},
				l = function (e) {
					angular.element("section.sidebar > ul li").removeClass("active"),
					angular.element("section.sidebar > ul > li[data-href-match]").each(function (t, a) {
						var n = angular.element(a).attr("data-href-match");
						r(n, e) && angular.element(a).addClass("active")
					}),
					angular.element("section.sidebar > ul > li.treeview > ul.treeview-menu > li[data-href-match]").each(function (t, a) {
						var n = angular.element(a).attr("data-href-match");
						r(n, e) && angular.element(a).addClass("active").parent().parent().addClass("active")
					})
				},
				c = function () {
					angular.element("body").removeClass("sidebar-collapse").addClass("sidebar-open")
				},
				d = function () {
					angular.element("body").addClass("sidebar-collapse").removeClass("sidebar-open")
				},
				u = function () {
					return angular.element("body").hasClass("sidebar-open")
				};
				e.searchContext = {
					text: ""
				},
				e.taskContext = {
					rpcStatus: "Connecting",
					list: [],
					selected: {},
					enableSelectAll: !1,
					getSelectedTaskIds: function () {
						var e = [];
						if (!this.list || !this.selected || this.list.length < 1)
							return e;
						for (var t = 0; t < this.list.length; t++) {
							var a = this.list[t];
							this.selected[a.gid] && e.push(a.gid)
						}
						return e
					},
					getSelectedTasks: function () {
						var e = [];
						if (!this.list || !this.selected || this.list.length < 1)
							return e;
						for (var t = 0; t < this.list.length; t++) {
							var a = this.list[t];
							this.selected[a.gid] && e.push(a)
						}
						return e
					},
					selectAll: function () {
						if (this.list && this.selected && !(this.list.length < 1) && this.enableSelectAll) {
							for (var e = !0, t = 0; t < this.list.length; t++) {
								var a = this.list[t];
								if (!this.selected[a.gid]) {
									e = !1;
									break
								}
							}
							for (var t = 0; t < this.list.length; t++) {
								var a = this.list[t];
								this.selected[a.gid] = !e
							}
						}
					}
				},
				e.swipeActions = {
					leftSwipe: function () {
						if (u())
							return void d();
						(!this.extentLeftSwipe || angular.isFunction(this.extentLeftSwipe) && !this.extentLeftSwipe()) && d()
					},
					rightSwipe: function () {
						(!this.extentRightSwipe || angular.isFunction(this.extentRightSwipe) && !this.extentRightSwipe()) && c()
					}
				},
				s.onFirstAccess(function () {
					i.notifyInPage("", "Tap to configure and get started with AriaNg.", {
						delay: !1,
						onClose: function () {
							t.path("/settings/ariang")
						}
					})
				}),
				o.onFirstSuccess(function () {
					i.notifyInPage("", "Connection Succeeded", {
						type: "success"
					})
				}),
				o.onConnectSuccess(function () {
					e.taskContext.rpcStatus = "Connected"
				}),
				o.onConnectError(function () {
					e.taskContext.rpcStatus = "Not Connected"
				}),
				o.onTaskCompleted(function (e) {
					i.notifyTaskComplete(e.task)
				}),
				o.onBtTaskCompleted(function (e) {
					i.notifyBtTaskComplete(e.task)
				}),
				o.onTaskErrorOccur(function (e) {
					i.notifyTaskError(e.task)
				}),
				e.$on("$locationChangeStart", function (t) {
					n.close(),
					e.loadPromise = null,
					delete e.swipeActions.extentLeftSwipe,
					delete e.swipeActions.extentRightSwipe,
					angular.isArray(e.taskContext.list) && e.taskContext.list.length > 0 && (e.taskContext.list.length = 0),
					angular.isObject(e.taskContext.selected) && (e.taskContext.selected = {}),
					e.taskContext.enableSelectAll = !1
				}),
				e.$on("$routeChangeStart", function (e, n, i) {
					var s = t.path();
					l(s),
					a.unbind("keypress")
				}),
				function () {
					angular.element("section.sidebar > ul > li[data-href-match] > a").click(function () {
						angular.element("section.sidebar > ul li").removeClass("active"),
						angular.element(this).parent().addClass("active")
					}),
					angular.element("section.sidebar > ul > li.treeview > ul.treeview-menu > li[data-href-match] > a").click(function () {
						angular.element("section.sidebar > ul li").removeClass("active"),
						angular.element(this).parent().addClass("active").parent().parent().addClass("active")
					})
				}
				()
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").constant("ariaNgConstants", {
		title: "AriaNg",
		appPrefix: "AriaNg",
		optionStorageKey: "Options",
		languageStorageKeyPrefix: "Language",
		languagePath: "langs",
		languageFileExtension: ".txt",
		defaultLanguage: "en",
		defaultHost: "localhost",
		globalStatStorageCapacity: 120,
		taskStatStorageCapacity: 300,
		lazySaveTimeout: 500,
		errorTooltipDelay: 500,
		notificationInPageTimeout: 2e3
	}).constant("ariaNgDefaultOptions", {
		language: "en",
		title: "${downspeed}, ${upspeed} - ${title}",
		titleRefreshInterval: 5e3,
		browserNotification: !1,
		rpcAlias: "",
		rpcHost: "",
		rpcPort: "6800",
		rpcInterface: "jsonrpc",
		protocol: "http",
		httpMethod: "POST",
		secret: "",
		extendRpcServers: [],
		globalStatRefreshInterval: 1e3,
		downloadTaskRefreshInterval: 1e3,
		afterCreatingNewTask: "task-list"
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").config(["$translateProvider", "localStorageServiceProvider", "NotificationProvider", "ariaNgConstants", function (e, t, a, n) {
				t.setPrefix(n.appPrefix).setStorageType("localStorage").setStorageCookie(365, "/"),
				e.useLoader("ariaNgLanguageLoader").useLoaderCache(!0).preferredLanguage(n.defaultLanguage).fallbackLanguage(n.defaultLanguage).useSanitizeValueStrategy("escapeParameters"),
				a.setOptions({
					delay: n.notificationInPageTimeout
				})
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").constant("ariaNgFileTypes", {
		video: [".3g2", ".3gp", ".3gp2", ".3gpp", ".asf", ".asx", ".avi", ".dat", ".divx", ".flv", ".m1v", ".m2ts", ".m2v", ".m4v", ".mkv", ".mov", ".mp4", ".mpe", ".mpeg", ".mpg", ".mts", ".ogv", ".qt", ".ram", ".rm", ".rmvb", ".ts", ".vob", ".wmv"],
		audio: [".aac", ".ac3", ".adts", ".amr", ".ape", ".eac3", ".flac", ".m1a", ".m2a", ".m4a", ".mid", ".mka", ".mp2", ".mp3", ".mpa", ".mpc", ".ogg", ".ra", ".tak", ".vqf", ".wm", ".wav", ".wma", ".wv"],
		picture: [".abr", ".bmp", ".emf", ".gif", ".j2c", ".j2k", ".jfif", ".jif", ".jp2", ".jpc", ".jpe", ".jpeg", ".jpf", ".jpg", ".jpk", ".jpx", ".pcx", ".pct", ".pic", ".pict", ".png", ".pns", ".psd", ".psdx", ".raw", ".svg", ".svgz", ".tga", ".tif", ".tiff", ".wbm", ".wbmp", ".webp", ".wmf", ".xif"],
		document: [".csv", ".doc", ".docm", ".docx", ".dot", ".dotm", ".dotx", ".key", ".mpp", ".numbers", ".odp", ".ods", ".odt", ".pages", ".pdf", ".pot", ".potm", ".potx", ".pps", ".ppsm", ".ppsx", ".ppt", ".pptm", ".pptx", ".rtf", ".txt", ".vsd", ".vsdx", ".wk1", ".wk2", ".wk3", ".wk4", ".wks", ".wpd", ".wps", ".xla", ".xlam", ".xll", ".xlm", ".xls", ".xlsb", ".xlsm", ".xlsx", ".xlt", ".xltx", ".xlw", ".xps"],
		application: [".apk", ".bat", ".com", ".deb", ".dll", ".dmg", ".exe", ".ipa", ".jar", ".msi", ".rpm", ".sh"],
		archive: [".001", ".7z", ".ace", ".arj", ".bz2", ".cab", ".cbr", ".cbz", ".gz", ".img", ".iso", ".lzh", ".qcow2", ".r", ".rar", ".sef", ".tar", ".taz", ".tbz", ".tbz2", ".uue", ".vdi", ".vhd", ".vmdk", ".wim", ".xar", ".xz", ".z", ".zip"]
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").run(["amMoment", "moment", "ariaNgSettingService", function (e, t, a) {
				var n = a.getLanguage();
				t.updateLocale("zh-cn", {
					week: null
				}),
				e.changeLocale(n),
				a.applyLanguage(n)
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").constant("ariaNgLanguages", {
		en: {
			name: "English",
			displayName: "English"
		},
		zh_CN: {
			name: "Simplified Chinese",
			displayName: "简体中文"
		}
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").config(["$translateProvider", "ariaNgConstants", function (e, t) {
				var a = {
					"Operation Succeeded": "操作成功",
					"Connection Succeeded": "连接成功",
					Error: "错误",
					OK: "确定",
					Confirm: "确认",
					Cancel: "取消",
					True: "True",
					False: "False",
					Connecting: "连接中",
					Connected: "已连接",
					"Not Connected": "未连接",
					Global: "全局",
					New: "新建",
					Start: "开始",
					Pause: "暂停",
					Restart: "重试",
					Delete: "删除",
					"Select All": "全选",
					"Select None": "全不选",
					"Select Invert": "反选",
					"Display Order": "显示顺序",
					Help: "帮助",
					Search: "搜索",
					Default: "默认",
					Expand: "展开",
					Collapse: "折叠",
					"Remove Task": "删除任务",
					"Clear Stopped Tasks": "清空已结束任务",
					"Click to view task detail": "点击查看任务详情",
					"By File Name": "按文件名",
					"By File Size": "By File Size",
					"By Progress": "By Progress",
					"By Remain Time": "By Remain Time",
					"By Download Speed": "By Download Speed",
					"By Upload Speed": "By Upload Speed",
					Filters: "过滤器",
					Download: "下载",
					Upload: "上传",
					Downloading: "下载中",
					Seeding: "正在做种",
					Waiting: "正在等待",
					Paused: "暂停",
					Completed: "已完成",
					"Error Occurred": "发生错误",
					Removed: "已删除",
					"Finished / Stopped": "已完成 / 已停止",
					Uncompleted: "未完成",
					"Click to pin": "点击固定",
					Settings: "系统设置",
					"AriaNg Settings": "AriaNg Settings",
					"Aria2 Settings": "Aria2 Settings",
					"Basic Settings": "Basic Settings",
					"HTTP/FTP/SFTP Settings": "HTTP/FTP/SFTP Settings",
					"HTTP Settings": "HTTP Settings",
					"FTP/SFTP Settings": "FTP/SFTP Settings",
					"BitTorrent Settings": "BitTorrent Settings",
					"Metalink Settings": "Metalink Settings",
					"RPC Settings": "RPC Settings",
					"Advanced Settings": "Advanced Settings",
					"Aria2 Status": "Aria2 Status",
					"File Name": "文件名",
					"File Size": "大小",
					Progress: "进度",
					"Share Ratio": "分享率",
					"Remain Time": "剩余时间",
					"Download Speed": "下载速度",
					"Upload Speed": "上传速度",
					Links: "链接",
					"Torrent File": "种子文件",
					"Metalink File": "Metalink 文件",
					"File Name:": "文件名:",
					Options: "选项",
					Overview: "总览",
					Blocks: "区块信息",
					Files: "文件列表",
					Peers: "连接状态",
					"Task Name": "任务名称",
					"Task Size": "任务大小",
					"Task Status": "任务状态",
					"Error Description": "错误描述",
					"Health Percentage": "健康度",
					"Info Hash": "特征值",
					Seeders: "种子数",
					Connections: "连接数",
					"Seed Creation Time": "种子创建时间",
					"Download Dir": "下载路径",
					"BT Tracker Servers": "BT 服务器",
					"(Choose Files)": "(选择文件)",
					Videos: "视频",
					Audios: "音频",
					Pictures: "图片",
					Documents: "文档",
					Applications: "应用",
					Archives: "存档文件",
					Address: "地址",
					Client: "客户端",
					Status: "状态",
					Speed: "速度",
					"(local)": "(本机)",
					"No Data": "无数据",
					"No connected peers": "没有连接到其他节点",
					"Failed to change some tasks state.": "修改一些任务状态时失败.",
					"Confirm Restart": "确认重试",
					"Are you sure you want to restart this task? AriaNg will create a same task after clicking OK.": "您是否要重试这个任务? 点击 确定 后, AriaNg 将会创建一个相同的任务.",
					"Failed to restart this task.": "该任务重试失败.",
					"Confirm Remove": "确认删除",
					"Are you sure you want to remove the selected task?": "您是否要删除选中的任务?",
					"Failed to remove some task(s).": "删除一些任务时失败.",
					"Confirm Clear": "确认清除",
					"Are you sure you want to clear stopped tasks?": "您是否要清除已结束的任务?",
					"Download Links:": "下载链接:",
					"Open Torrent File": "打开种子文件",
					"Open Metalink File": "打开 Metalink 文件",
					"Start Download": "立即下载",
					"Manual Download": "Manual 下载",
					"Support multiple URLs, one URL per line.": "支持多个 URL 地址, 每个地址占一行.",
					"Your browser does not support loading file!": "您的浏览器不支持加载文件!",
					"The selected file type is invalid!": "选择的文件类型无效!",
					"Failed to load file!": "加载文件失败!",
					"Download Completed": "下载完成",
					"BT Download Completed": "BT 下载完成",
					"Download Error": "下载出错",
					Language: "语言",
					"Debug Mode": "调试模式",
					"Page Title": "页面标题",
					Preview: "预览",
					'Tips: You can use the "noprefix" tag to ignore the prefix, "nosuffix" tag ignore the suffix, and "scale=n" tag to set the decimal precision.': '小提示: 您可以使用 "noprefix" 标签忽略前缀, "nosuffix" 标签忽略后缀, 以及 "scale\=n" 标签设置小数的精度.',
					"Example: ${downspeed:noprefix:nosuffix:scale=1}": "示例: ${downspeed:noprefix:nosuffix:scale\=1}",
					"Page Title Refresh Interval": "页面标题刷新间隔",
					"Enable Browser Notification": "启用浏览器通知",
					"Aria2 RPC Alias": "Aria2 RPC 别名",
					"Aria2 RPC Address": "Aria2 RPC 地址",
					"Aria2 RPC Protocol": "Aria2 RPC 协议",
					"Aria2 RPC Http Request Method": "Aria2 RPC Http 请求方法",
					"POST method only supports aria2 v1.15.2 and above.": "POST 方法仅支持 aria2 v1.15.2 及以上.",
					"Aria2 RPC Secret Token": "Aria2 RPC 密钥",
					Activate: "激活",
					"Delete RPC Setting": "删除 RPC 设置",
					"Add New RPC Setting": "添加新 RPC 配置",
					'Are you sure you want to remove rpc setting "{{rpcName}}"?': '您是否要删除 RPC 设置 "{{rpcName}}"?',
					"Global Stat Refresh Interval": "全局状态刷新间隔",
					"Download Task Refresh Interval": "下载任务刷新间隔",
					"Action After Creating New Tasks": "创建新任务后执行操作",
					"Navigate to Task List Page": "转到任务列表页面",
					"Navigate to Task Detail Page": "转到任务详情页面",
					"Supported Placeholder": "支持的占位符",
					"AriaNg Title": "AriaNg 标题",
					"Downloading Count": "正在下载数量",
					"Waiting Count": "正在等待数量",
					"Stopped Count": "已停止数量",
					"You have disabled notification in your browser. You should change your browser's settings before you enable this function.": "您已经在浏览器中禁用通知功能. 如需使用此功能, 请修改您浏览器的设置.",
					"Configuration has been modified, please reload the page for the changes to take effect.": "配置已经修改, 请重新加载页面使其生效.",
					"Reload Page": "重新加载页面",
					"Show Secret": "显示密钥",
					"Hide Secret": "隐藏密钥",
					"Aria2 Version": "Aria2 版本",
					"Enabled Features": "已启用的功能",
					Functions: "方法",
					"Save Session": "保存会话",
					"Shutdown Aria2": "关闭 Aria2",
					"Confirm Shutdown": "确认关闭",
					"Are you sure you want to shutdown aria2?": "您是否要关闭 aria2?",
					"Session has been saved successfully.": "会话已经成功保存.",
					"Aria2 has been shutdown successfully.": "Aria2 已经成功关闭.",
					"Toggle Navigation": "切换导航",
					"Quick Setting": "Quick Setting",
					"Global Speed Limit": "Global Speed Limit",
					Loading: "正在加载...",
					"More Than One Day": "超过1天",
					Unknown: "未知",
					Bytes: "字节",
					Hours: "小时",
					Minutes: "分钟",
					Seconds: "秒",
					Milliseconds: "毫秒",
					Http: "Http",
					Https: "Https",
					WebSocket: "WebSocket",
					"WebSocket (Security)": "WebSocket (安全)",
					POST: "POST",
					GET: "GET",
					Disabled: "禁用",
					BitTorrent: "BitTorrent",
					"Changes to the settings take effect after refreshing page.": "设置将在页面刷新后生效.",
					"Type is illegal!": "类型错误!",
					"Parameter is invalid!": "请求参数无效!",
					"Option value cannot be empty!": "参数内容不能为空!",
					"Input number is invalid!": "输入的数字小于最小值",
					"Input number is below min value!": "输入的数字小于最小值 {{value}} !",
					"Input number is above max value!": "输入的数字大于最大值 {{value}} !",
					"Input value is invalid!": "输入的内容无效!",
					"Protocol is invalid!": "协议无效!",
					"RPC host cannot be empty!": "RPC 主机不能为空!",
					"RPC secret is not base64 encoded!": "RPC 密钥不是 Base64 编码后的字符串!",
					"URL is not base64 encoded!": "指定 URL 不是 Base64 编码后的字符串!",
					"Tap to configure and get started with AriaNg.": "您还没有进行过设置, 点击这里进行设置.",
					error: {
						unknown: "未知错误.",
						"operation.timeout": "操作超时.",
						"resource.notfound": "无法找到指定资源.",
						"error.resource.notfound.max-file-not-found": "无法找到指定资源. 参见 --max-file-not-found option 参数.",
						"error.download.aborted.lowest-speed-limit": "由于下载速度过慢, 下载已经终止. 参见 --lowest-speed-limit option 参数.",
						"network.problem": "网络问题.",
						"resume.notsupported": "服务器不支持断点续传.",
						"space.notenough": "可用磁盘空间不足.",
						"piece.length.different": "分片大小与 .aria2 控制文件中的不同. 参见 --allow-piece-length-change 参数.",
						"download.sametime": "aria2 已经下载了另一个相同文件",
						"download.torrent.sametime": "aria2 已经下载了另一个相同哈希的种子文件.",
						"file.exists": "文件已经存在. 参见 --allow-overwrite 参数.",
						"file.rename.failed": "文件重命名失败. 参见 --auto-file-renaming 参数.",
						"file.open.failed": "文件打开失败.",
						"file.create.failed": "文件创建或删除已有文件失败.",
						"io.error": "文件系统出错.",
						"directory.create.failed": "无法创建指定目录.",
						"name.resolution.failed": "域名解析失败.",
						"metalink.file.parse.failed": "解析 Metalink 文件失败.",
						"ftp.command.failed": "FTP 命令执行失败.",
						"http.response.header.bad": "HTTP 返回头无效或无法识别.",
						"redirects.toomany": "指定地址重定向过多.",
						"http.authorization.failed": "HTTP 认证失败.",
						"bencoded.file.parse.failed": '解析种子文件失败.',
						"torrent.file.corrupted": '指定 ".torrent" 种子文件已经损坏或缺少 aria2 需要的信息.',
						"magnet.uri.bad": "指定磁链地址无效.",
						"option.bad": "设置错误.",
						"server.overload": "远程服务器繁忙, 无法处理当前请求.",
						"rpc.request.parse.failed": "处理 RPC 请求失败.",
						"checksum.failed": "文件校验失败."
					},
					format: {
						longdate: "MM/DD/YYYY HH:mm:ss",
						"time.millisecond": "{{value}} 毫秒",
						"time.milliseconds": "{{value}} 毫秒",
						"time.second": "{{value}} 秒",
						"time.seconds": "{{value}} 秒",
						"time.minute": "{{value}} 分钟",
						"time.minutes": "{{value}} 分钟",
						"time.hour": "{{value}} 小时",
						"time.hours": "{{value}} 小时",
						"requires.aria2-version": "需要 aria2 v{{version}} 或更高版本",
						"task.pieceinfo": "已完成: {{completed}}, 共计: {{total}} 块",
						"task.error-occurred": "发生错误 ({{errorcode}})",
						"settings.file-count": "({{count}} 个文件)",
						"settings.total-count": "(共计: {{count}}个)"
					},
					rpc: {
						error: {
							unauthorized: "认证失败!"
						}
					},
					options: {
						true: "True",
						false: "False",
					default:
						"Default",
						none: "None",
						hide: "Hide",
						full: "Full",
						http: "Http",
						https: "Https",
						ftp: "Ftp",
						mem: "近内存",
						get: "GET",
						tunnel: "TUNNEL",
						plain: "明文",
						arc4: "ARC4",
						binary: "二进制",
						ascii: "ASCII",
						debug: "Debug",
						info: "Info",
						notice: "Notice",
						warn: "Warn",
						error: "Error",
						adaptive: "adaptive",
						epoll: "epoll",
						falloc: "falloc",
						feedback: "feedback",
						geom: "geom",
						inorder: "inorder",
						kqueue: "kqueue",
						poll: "poll",
						port: "port",
						prealloc: "prealloc",
						random: "random",
						select: "select",
						trunc: "trunc",
						SSLv3: "SSLv3",
						TLSv1: "TLSv1",
						"TLSv1.1": "TLSv1.1",
						"TLSv1.2": "TLSv1.2",
						"dir.name": "下载路径",
						"dir.description": "",
						"log.name": "日志文件",
						"log.description": '日志文件的路径. 如果设置为 "-", 日志则写入到 stdout. 如果设置为空字符串(""), 日志将不会记录到磁盘上.',
						"max-concurrent-downloads.name": "最大同时下载数",
						"max-concurrent-downloads.description": "",
						"check-integrity.name": "检查完整性",
						"check-integrity.description": "通过对文件的每个分块或整个文件进行哈希验证来检查文件的完整性. 此选项仅对BT、Metalink及设置了 --checksum 选项的 HTTP(S)/FTP 链接生效.",
						"continue.name": "断点续传",
						"continue.description": "继续下载部分完成的文件. 启用此选项可以继续下载从浏览器或其他程序按顺序下载的文件. 此选项目前只支持 HTTP(S)/FTP 下载的文件.",
						"all-proxy.name": "代理服务器",
						"all-proxy.description": '设置所有协议的代理服务器地址. 如果覆盖之前设置的代理服务器, 使用 "" 即可. 您还可以针对特定的协议覆盖此选项, 即使用 --http-proxy, --https-proxy 和 --ftp-proxy 选项. 此设置将会影响所有下载. 代理服务器地址的格式为 [http://][USER:PASSWORD@]HOST[:PORT].',
						"all-proxy-user.name": "代理服务器用户名",
						"all-proxy-user.description": "",
						"all-proxy-passwd.name": "代理服务器密码",
						"all-proxy-passwd.description": "",
						"connect-timeout.name": "连接超时时间",
						"connect-timeout.description": "设置建立 HTTP/FTP/代理服务器 连接的超时时间(秒). 当连接建立后, 此选项不再生效, 请使用 --timeout 选项.",
						"dry-run.name": "模拟运行",
						"dry-run.description": '如果设置为"是", aria2 将仅检查远程文件是否存在而不会下载文件内容. 此选项仅对 HTTP/FTP 下载生效. 如果设置为 true, BT 下载将会直接取消.',
						"lowest-speed-limit.name": "最小速度限制",
						"lowest-speed-limit.description": "当下载速度低于此选项设置的值(B/s) 时将会关闭连接. 0 表示不设置最小速度限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). 此选项不会影响 BT 下载.",
						"max-connection-per-server.name": "单服务器最大连接数",
						"max-connection-per-server.description": "",
						"max-file-not-found.name": "文件未找到重试次数",
						"max-file-not-found.description": '如果 aria2 从远程 HTTP/FTP 服务器收到 "文件未找到" 的状态超过此选项设置的次数后下载将会失败. 设置为 0 将会禁用此选项. 此选项仅影响 HTTP/FTP 服务器. 重试时同时会记录重试次数, 所以也需要设置 --max-tries 这个选项.',
						"max-tries.name": "最大尝试次数",
						"max-tries.description": "设置最大尝试次数. 0 表示不限制.",
						"min-split-size.name": "最小文件分片大小",
						"min-split-size.description": "aria2 不会分割小于 2*SIZE 字节的文件. 例如, 文件大小为 20MB, 如果 SIZE 为 10M, aria2 会把文件分成 2 段 [0-10MB) 和 [10MB-20MB), 并且使用 2 个源进行下载 (如果 --split >= 2). 如果 SIZE 为 15M, 由于 2*15M > 20MB, 因此 aria2 不会分割文件并使用 1 个源进行下载. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K). 可以设置的值为: 1M-1024M.",
						"netrc-path.name": ".netrc 文件路径",
						"netrc-path.description": "",
						"no-netrc.name": "禁用 netrc",
						"no-netrc.description": "",
						"no-proxy.name": "不使用代理服务器列表",
						"no-proxy.description": "Specify a comma separated list of host names, domains and network addresses with or without a subnet mask where no proxy should be used.",
						"out.name": "文件名",
						"out.description": "下载文件的文件名. 其总是相对于 --dir 选项中设置的路径. 当使用 --force-sequential 参数时此选项无效.",
						"proxy-method.name": "代理服务器请求方法",
						"proxy-method.description": "设置不使用代理服务器的主机名, 域名, 包含或不包含子网掩码的网络地址, 多个使用逗号分隔.",
						"remote-time.name": "获取服务器文件时间",
						"remote-time.description": "从 HTTP/FTP 服务获取远程文件的时间戳, 如果可用将设置到本地文件",
						"reuse-uri.name": "URI 复用",
						"reuse-uri.description": "当所有给定的 URI 地址都已使用, 继续使用已经使用过的 URI 地址.",
						"retry-wait.name": "重试等待时间",
						"retry-wait.description": "设置重试间隔时间(秒). 当此选项的值大于 0 时, aria2 在 HTTP 服务器返回 503 响应时将会重试.",
						"server-stat-of.name": "服务器状态保存文件",
						"server-stat-of.description": "指定用来保存服务器状态的文件名. 您可以使用 --server-stat-if 参数读取保存的数据.",
						"server-stat-timeout.name": "服务器状态超时",
						"server-stat-timeout.description": "指定服务器状态的过期时间 (单位为秒).",
						"split.name": "单任务连接数",
						"split.description": "下载时使用 N 个连接. 如果提供超过 N 个 URI 地址, 则使用前 N 个地址, 剩余的地址将作为备用. 如果提供的 URI 地址不足 N 个, 这些地址多次使用以保证同时建立 N 个连接. 同一服务器的连接数会被 --max-connection-per-server 选项限制.",
						"stream-piece-selector.name": "分片选择算法",
						"stream-piece-selector.description": '指定 HTTP/FTP 下载使用的分片选择算法. 分片表示的是并行下载时固定长度的分隔段. 如果设置为"默认", aria2 将会按减少建立连接数选择分片. 由于建立连接操作的成本较高, 因此这是合理的默认行为. 如果设置为"顺序", aria2 将选择索引最小的分片. 索引为 0 时表示为文件的第一个分片. 这将有助于视频的边下边播. --enable-http-pipelining 选项有助于减少重连接的开销. 请注意, aria2 依赖于 --min-split-size 选项, 所以有必要对 --min-split-size 选项设置一个合理的值. 如果设置为"随机", aria2 将随机选择一个分片. 就像"顺序"一样, 依赖于 --min-split-size 选项. 如果设置为"几何", aria2 会先选择索引最小的分片, 然后会为之前选择的分片保留指数增长的空间. 这将减少建立连接的次数, 同时文件开始部分将会先行下载. 这也有助于视频的边下边播.',
						"timeout.name": "超时时间",
						"timeout.description": "",
						"uri-selector.name": "URI 选择算法",
						"uri-selector.description": '指定 URI 选择的算法. 可选的值包括 "按顺序", "反馈" 和 "自适应". 如果设置为"按顺序", URI 将按列表中出现的顺序使用. 如果设置为"反馈", aria2 将根据之前的下载速度选择 URI 列表中下载速度最快的服务器. 同时也将有效跳过无效镜像. 之前统计的下载速度将作为服务器状态文件的一部分, 参见 --server-stat-of 和 --server-stat-if 选项. 如果设置为"自适应", 将从最好的镜像和保留的连接里选择一项. 补充说明, 其返回的镜像没有被测试过, 同时如果每个镜像都已经被测试过时, 返回的镜像还会被重新测试. 否则, 其将不会选择其他镜像. 例如"反馈", 其使用服务器状态文件.',
						"check-certificate.name": "检查证书",
						"check-certificate.description": "",
						"http-accept-gzip.name": "支持 GZip",
						"http-accept-gzip.description": "如果远程服务器的响应头中包含 Content-Encoding: gzip 或 Content-Encoding: deflate , 将发送包含 Accept: deflate, gzip 的请求头并解压缩响应.",
						"http-auth-challenge.name": "认证质询",
						"http-auth-challenge.description": '仅当服务器需要时才发送 HTTP 认证请求头. 如果设置为"否", 每次都会发送认证请求头. 例外: 如果用户名和密码包含在 URI 中, 将忽略此选项并且每次都会发送认证请求头.',
						"http-no-cache.name": "禁用缓存",
						"http-no-cache.description": '发送的请求头中将包含 Cache-Control: no-cache 和 Pragma: no-cache header 以避免内容被缓存. 如果设置为"否", 上述请求头将不会发送, 同时您也可以使用 --header 选项将 Cache-Control 请求头添加进去.',
						"http-user.name": "HTTP 默认用户名",
						"http-user.description": "",
						"http-passwd.name": "HTTP 默认密码",
						"http-passwd.description": "",
						"http-proxy.name": "HTTP 代理服务器",
						"http-proxy.description": "",
						"http-proxy-user.name": "HTTP 代理服务器用户名",
						"http-proxy-user.description": "",
						"http-proxy-passwd.name": "HTTP 代理服务器密码",
						"http-proxy-passwd.description": "",
						"https-proxy.name": "HTTPS 代理服务器",
						"https-proxy.description": "",
						"https-proxy-user.name": "HTTPS 代理服务器用户名",
						"https-proxy-user.description": "",
						"https-proxy-passwd.name": "HTTPS 代理服务器密码",
						"https-proxy-passwd.description": "",
						"referer.name": "请求来源",
						"referer.description": "设置 HTTP 请求来源 (Referer). 此选项将影响所有 HTTP/HTTPS 下载. 如果设置为 *, 请求来源将设置为下载链接. 此选项可以配合 --parameterized-uri 选项使用.",
						"enable-http-keep-alive.name": "启用持久连接",
						"enable-http-keep-alive.description": "启用 HTTP/1.1 持久连接.",
						"enable-http-pipelining.name": "启用 HTTP 管线化",
						"enable-http-pipelining.description": "启用 HTTP/1.1 管线化.",
						"header.name": "自定义请求头",
						"header.description": "增加 HTTP 请求头内容.",
						"save-cookies.name": "Cookies 保存路径",
						"save-cookies.description": "以 Mozilla/Firefox(1.x/2.x)/Netscape 格式将 Cookies 保存到文件中. 如果文件已经存在, 将被覆盖. 会话过期的 Cookies 也将会保存, 其过期时间将会设置为 0.",
						"use-head.name": "启用 HEAD 方法",
						"use-head.description": "第一次请求 HTTP 服务器时使用 HEAD 方法.",
						"user-agent.name": "自定义 User Agent",
						"user-agent.description": "",
						"ftp-user.name": "FTP 默认用户名",
						"ftp-user.description": "",
						"ftp-passwd.name": "FTP 默认密码",
						"ftp-passwd.description": "如果 URI 中包含用户名单不包含密码, aria2 首先会从 .netrc 文件中获取密码. 如果在 .netrc 文件中找到密码, 则使用该密码. 否则, 使用此选项设置的密码.",
						"ftp-pasv.name": "被动模式",
						"ftp-pasv.description": '在 FTP 中使用被动模式. 如果设置为"否", 则使用主动模式. 此选项不适用于 SFTP 传输.',
						"ftp-proxy.name": "FTP 代理服务器",
						"ftp-proxy.description": "",
						"ftp-proxy-user.name": "FTP 代理服务器用户名",
						"ftp-proxy-user.description": "",
						"ftp-proxy-passwd.name": "FTP 代理服务器密码",
						"ftp-proxy-passwd.description": "",
						"ftp-type.name": "传输类型",
						"ftp-type.description": "",
						"ftp-reuse-connection.name": "连接复用",
						"ftp-reuse-connection.description": "",
						"ssh-host-key-md.name": "SSH 公钥校验和",
						"ssh-host-key-md.description": "设置 SSH 主机公钥的校验和. TYPE 为哈希类型. 支持的哈希类型为 sha-1 和 md5. DIGEST 是十六进制摘要. 例如: sha-1=b030503d4de4539dc7885e6f0f5e256704edf4c3. 此选项可以在使用 SFTP 时用来验证服务器的公钥. 如果此选项不设置, 即保留默认, 不会进行任何验证.",
						"bt-detach-seed-only.name": "分离仅做种任务",
						"bt-detach-seed-only.description": "统计当前活动下载任务(参见 -j 选项) 时排除仅做种的任务. 这意味着, 如果参数设置为 -j3, 此选项打开并且当前有 3 个正在活动的任务, 并且其中有 1 个进入做种模式, 那么其会从正在下载的数量中排除(即数量会变为 2), 在队列中等待的下一个任务将会开始执行. 但要知道, 在 RPC 方法中, 做种的任务仍然被认为是活动的下载任务.",
						"bt-enable-hook-after-hash-check.name": "启用哈希检查完成事件",
						"bt-enable-hook-after-hash-check.description": '允许 BT 下载哈希检查(参见 -V 选项) 完成后调用命令. 默认情况下, 当哈希检查成功后, 通过 --on-bt-download-complete 设置的命令将会被执行. 如果要禁用此行为, 请设置为"否".',
						"bt-enable-lpd.name": "启用本地节点发现  (LPD)",
						"bt-enable-lpd.description": "Enable Local Peer Discovery. If a private flag is set in a torrent, aria2 doesn't use this feature for that download even if true is given.",
						"bt-exclude-tracker.name": "BT 排除服务器地址",
						"bt-exclude-tracker.description": "逗号分隔的 BT 排除服务器地址. 您可以使用 * 匹配所有地址, 因此将排除所有服务器地址. 当在 shell 命令行使用 * 时, 需要使用转义符或引号.",
						"bt-external-ip.name": "外部 IP 地址",
						"bt-external-ip.description": "指定用在 BitTorrent 下载和 DHT 中的外部 IP 地址. 它可能被发送到 BitTorrent 服务器. 对于 DHT, 此选项将会报告本地节点正在下载特定的种子. 这对于在私有网络中使用 DHT 非常关键. 虽然这个方法叫外部, 但其可以接受各种类型的 IP 地址.",
						"bt-force-encryption.name": "强制加密",
						"bt-force-encryption.description": 'BT 消息中的内容需要使用 arc4 加密. 此选项是设置 --bt-require-crypto --bt-min-crypto-level=arc4 这两个选项的快捷方式. 此选项不会修改上述两个选项的内容. 如果设置为"是", 将拒绝以前的 BT 握手, 并仅使用模糊握手及加密消息.',
						"bt-hash-check-seed.name": "做种前检查文件哈希",
						"bt-hash-check-seed.description": '如果设置为"是", 当使用 --check-integrity 选项完成哈希检查及文件完成后才继续做种. 如果您希望仅当文件损坏或未完成时检查文件, 请设置为"否". 此选项仅对 BT 下载有效',
						"bt-max-open-files.name": "最多打开文件数",
						"bt-max-open-files.description": "设置 BT/Metalink 下载全局打开的最大文件数.",
						"bt-max-peers.name": "最大连接节点数",
						"bt-max-peers.description": "设置每个 BT 下载的最大连接节点数. 0 表示不限制.",
						"bt-metadata-only.name": "仅下载种子文件",
						"bt-metadata-only.description": "仅下载种子文件. 种子文件中描述的文件将不会下载. 此选项仅对磁链生效.",
						"bt-min-crypto-level.name": "最低加密级别",
						"bt-min-crypto-level.description": "设置加密方法的最小级别. 如果节点提供多种加密方法, aria2 将选择满足给定级别的最低级别.",
						"bt-prioritize-piece.name": "优先下载",
						"bt-prioritize-piece.description": "尝试先下载每个文件开头或结尾的分片. 此选项有助于预览文件. 参数可以包括两个关键词: head 和 tail. 如果包含两个关键词, 需要使用逗号分隔. 每个关键词可以包含一个参数, SIZE. 例如, 如果指定 head=SIZE, 每个文件的最前 SIZE 数据将会获得更高的优先级. tail=SIZE 表示每个文件的最后 SIZE 数据. SIZE 可以包含 K 或 M (1K = 1024, 1M = 1024K).",
						"bt-remove-unselected-file.name": "删除未选择的文件",
						"bt-remove-unselected-file.description": "当 BT 任务完成后删除未选择的文件. 要选择需要下载的文件, 请使用 --select-file 选项. 如果没有选择, 则所有文件都默认为需要下载. 此选项会从磁盘上直接删除文件, 请谨慎使用此选项.",
						"bt-require-crypto.name": "需要加密",
						"bt-require-crypto.description": '如果设置为"是", aria 将不会接受以前的 BitTorrent 握手协议(\\19BitTorrent 协议)并建立连接. 因此 aria2 总是模糊握手.',
						"bt-request-peer-speed-limit.name": "期望下载速度",
						"bt-request-peer-speed-limit.description": "如果一个 BT 下载的整体下载速度低于此选项设置的值, aria2 会临时提高连接数以提高下载速度. 在某些情况下, 设置期望下载速度可以提高您的下载速度. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).",
						"bt-save-metadata.name": "保存种子文件",
						"bt-save-metadata.description": '保存种子文件为 ".torrent" 文件. 此选项仅对磁链生效. 文件名为十六进制编码后的哈希值及 ".torrent"后缀. 保存的目录与下载文件的目录相同. 如果相同的文件已存在, 种子文件将不会保存.',
						"bt-seed-unverified.name": "不检查已经下载的文件",
						"bt-seed-unverified.description": "不检查之前下载文件中每个分片的哈希值.",
						"bt-stop-timeout.name": "无速度时自动停止时间",
						"bt-stop-timeout.description": "当 BT 任务F下载速度持续为 0, 达到此选项设置的时间后停止下载. 如果设置为 0, 此功能将禁用.",
						"bt-tracker.name": "BT 服务器地址",
						"bt-tracker.description": "逗号分隔的 BT 服务器地址. 如果服务器地址在 --bt-exclude-tracker 选项中, 其将不会生效.",
						"bt-tracker-connect-timeout.name": "BT 服务器连接超时时间",
						"bt-tracker-connect-timeout.description": "设置 BT 服务器的连接超时时间 (秒). 当连接建立后, 此选项不再生效, 请使用 --bt-tracker-timeout 选项.",
						"bt-tracker-interval.name": "BT 服务器连接间隔时间",
						"bt-tracker-interval.description": "设置请求 BT 服务器的间隔时间 (秒). 此选项将完全覆盖服务器返回的最小间隔时间和间隔时间, aria2 仅使用此选项的值.如果设置为 0, aria2 将根据服务器的响应情况和下载进程决定时间间隔.",
						"bt-tracker-timeout.name": "BT 服务器超时时间",
						"bt-tracker-timeout.description": "",
						"dht-file-path.name": "DHT (IPv4) 文件",
						"dht-file-path.description": "修改 IPv4 DHT 路由表文件路径.",
						"dht-file-path6.name": "DHT (IPv6) 文件",
						"dht-file-path6.description": "修改 IPv6 DHT 路由表文件路径.",
						"dht-listen-port.name": "DHT 监听端口",
						"dht-listen-port.description": '设置 DHT (IPv4, IPv6) 和 UDP 服务器使用的 UCP 端口. 多个端口可以使用逗号 "," 分隔, 例如: 6881,6885. 您还可以使用短横线 "-" 表示范围: 6881-6999, 或可以一起使用: 6881-6889, 6999.',
						"dht-message-timeout.name": "DHT 消息超时时间",
						"dht-message-timeout.description": "",
						"enable-dht.name": "启用 DHT (IPv4)",
						"enable-dht.description": '启用 IPv4 DHT 功能. 此选项同时会启用 UDP 服务器支持. 如果种子设置为私有, 即使此选项设置为"是", aria2 也不会启用 DHT.',
						"enable-dht6.name": "启用 DHT (IPv6)",
						"enable-dht6.description": '启用 IPv6 DHT 功能. 如果种子设置为私有, 即使此选项设置为"是", aria2 也不会启用 DHT. 使用 --dht-listen-port 选项设置监听的端口.',
						"enable-peer-exchange.name": "启用节点交换",
						"enable-peer-exchange.description": '启用节点交换扩展. 如果种子设置为私有, 即使此选项设置为"是", aria2 也不会启用此功能.',
						"follow-torrent.name": "下载种子中的文件",
						"follow-torrent.description": '如果设置为"是"或"仅内存", 当后缀为 .torrent 或内容类型为 application/x-bittorrent 的文件下载完成时, aria2 将按种子文件读取并下载该文件中提到的文件. 如果设置为"仅内存", 该种子文件将不会写入到磁盘中, 而仅会存储在内存中. 如果设置为"否", 则 .torrent 文件会下载到磁盘中, 但不会按种子文件读取并且其中的文件不会进行下载.',
						"listen-port.name": "监听端口",
						"listen-port.description": '设置 BT 下载的 TCP 端口. 多个端口可以使用逗号 "," 分隔, 例如: 6881,6885. 您还可以使用短横线 "-" 表示范围: 6881-6999, 或可以一起使用: 6881-6889, 6999.',
						"max-overall-upload-limit.name": "全局最大上传速度",
						"max-overall-upload-limit.description": "设置全局最大上传速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).",
						"max-upload-limit.name": "最大上传速度",
						"max-upload-limit.description": "设置每个任务的最大上传速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).",
						"peer-id-prefix.name": "节点 ID 前缀",
						"peer-id-prefix.description": "指定节点 ID 的前缀. BT 中节点 ID 长度为 20 字节. 如果超过 20 字节, 将仅使用前 20 字节. 如果少于 20 字节, 将在其后不足随机的数据保证为 20 字节.",
						"seed-ratio.name": "最小分享率",
						"seed-ratio.description": "指定分享率. 当分享率达到此选项设置的值时会完成做种. 强烈建议您将此选项设置为大于等于 1.0. 如果您想不限制分享比率, 可以设置为 0.0. 如果同时设置了 --seed-time 选项, 当任意一个条件满足时将停止做种.",
						"seed-time.name": "最小做种时间",
						"seed-time.description": "此选项设置为 0 时, 将在 BT 任务下载完成后不进行做种.",
						"follow-metalink.name": "下载 Metalink 中的文件",
						"follow-metalink.description": '如果设置为"是"或"仅内存", 当后缀为 .meta4 或 .metalink 或内容类型为 application/metalink4+xml 或 application/metalink+xml 的文件下载完成时, aria2 将按 Metalink 文件读取并下载该文件中提到的文件. 如果设置为"仅内存", 该 Metalink 文件将不会写入到磁盘中, 而仅会存储在内存中. 如果设置为"否", 则 .metalink 文件会下载到磁盘中, 但不会按 Metalink 文件读取并且其中的文件不会进行下载.',
						"metalink-base-uri.name": "基础 URI",
						"metalink-base-uri.description": "指定基础 URI 以便解析本地磁盘中存储的 Metalink 文件里 metalink:url 和 metalink:metaurl 中的相对 URI 地址. 如果 URI 表示的为目录, 最后需要以 / 结尾.",
						"metalink-language.name": "语言",
						"metalink-language.description": "",
						"metalink-location.name": "首选服务器位置",
						"metalink-location.description": "首选服务器所在的位置. 可以使用逗号分隔的列表, 例如: jp,us.",
						"metalink-os.name": "操作系统",
						"metalink-os.description": "下载文件的操作系统.",
						"metalink-version.name": "版本号",
						"metalink-version.description": "下载文件的版本号.",
						"metalink-preferred-protocol.name": "首选使用协议",
						"metalink-preferred-protocol.description": '指定首选使用的协议. 可以设置为 http, https, ftp 或"无". 设置为"无"时禁用此选项.',
						"metalink-enable-unique-protocol.name": "仅使用唯一协议",
						"metalink-enable-unique-protocol.description": '如果一个 Metalink 文件可用多种协议, 并且此选项设置为"是", aria2 将只会使用其中一种. 使用 --metalink-preferred-protocol 参数指定首选的协议.',
						"enable-rpc.name": "启用 JSON-RPC/XML-RPC 服务器",
						"enable-rpc.description": "",
						"pause-metadata.name": "P种子文件下载完后暂停",
						"pause-metadata.description": "当种子文件下载完成后暂停后续的下载. 在 aria2 中有 3 种种子文件的下载类型: (1) 下载 .torrent 文件. (2) 通过磁链下载的种子文件. (3) 下载 Metalink 文件. 这些种子文件下载完后会根据文件内容继续进行下载. 此选项会暂停这些后续的下载. 此选项仅当 --enable-rpc 选项启用时生效.",
						"rpc-allow-origin-all.name": "接受所有远程请求",
						"rpc-allow-origin-all.description": "在 RPC 响应头增加 Access-Control-Allow-Origin 字段, 值为 * .",
						"rpc-listen-all.name": "在所有网卡上监听",
						"rpc-listen-all.description": '在所有网络适配器上监听 JSON-RPC/XML-RPC 的请求, 如果设置为"否", 仅监听本地网络的请求.',
						"rpc-listen-port.name": "监听端口",
						"rpc-listen-port.description": "",
						"rpc-max-request-size.name": "最大请求大小",
						"rpc-max-request-size.description": "设置 JSON-RPC/XML-RPC 最大的请求大小. 如果 aria2 检测到请求超过设定的字节数, 会直接取消连接.",
						"rpc-save-upload-metadata.name": "保存上传的种子文件",
						"rpc-save-upload-metadata.description": '在 dir 选项设置的目录中保存上传的种子文件或 Metalink 文件. 文件名包括 SHA-1 哈希后的元数据和扩展名两部分. 对于种子文件, 扩展名为 ".torrent". 对于 Metalink 为 ".meta4". 如果此选项设置为"否", 通过 aria2.addTorrent() 或 aria2.addMetalink() 方法添加的下载将无法通过 --save-session 选项保存.',
						"rpc-secure.name": "启用 SSL/TLS",
						"rpc-secure.description": "RPC 将通过 SSL/TLS 加密传输. RPC 客户端需要使用 https 协议连接服务器. 对于 WebSocket 客户端, 使用 wss 协议. 使用 --rpc-certificate 和 --rpc-private-key 选项设置服务器的证书和私钥.",
						"allow-overwrite.name": "允许覆盖",
						"allow-overwrite.description": "如果相应的控制文件不存在时从头重新下载文件. 参见 --auto-file-renaming 选项.",
						"allow-piece-length-change.name": "允许分片大小变化",
						"allow-piece-length-change.description": '如果设置为"否", 当分片长度与控制文件中的不同时, aria2 将会中止下载. 如果设置为"是", 您可以继续, 但部分下载进度将会丢失.',
						"always-resume.name": "始终断点续传",
						"always-resume.description": '始终断点续传. 如果设置为"是", aria2 始终尝试断点续传, 如果无法恢复, 则中止下载. 如果设置为"否", 对于不支持断点续传的 URI 或 aria2 遇到 N 个不支持断点续传的 URI (N 为 --max-resume-failure-tries 选项设置的值), aria2 会从头下载文件. 参见 --max-resume-failure-tries 参数.',
						"async-dns.name": "异步 DNS",
						"async-dns.description": "",
						"auto-file-renaming.name": "文件自动重命名",
						"auto-file-renaming.description": "重新命名已经存在的文件. 此选项仅对 HTTP(S)/FTP 下载有效. 新的文件名后会在文件名后、扩展名 (如果有) 前追加句点和数字(1..9999).",
						"auto-save-interval.name": "自动保存间隔",
						"auto-save-interval.description": "每隔设置的秒数自动保存控制文件(*.aria2). 如果设置为 0, 下载期间控制文件不会自动保存. 不论设置的值为多少, aria2 会在任务结束时保存控制文件. 可以设置的值为 0 到 600.",
						"conditional-get.name": "条件下载",
						"conditional-get.description": "仅当本地文件比远程文件旧时才进行下载. 此功能仅适用于 HTTP(S) 下载. 如果在 Metalink 中文件大小已经被指定则功能无法生效. 同时此功能还将忽略 Content-Disposition 响应头. 如果存在控制文件, 此选项将被忽略. 此功能通过 If-Modified-Since 请求头获取较新的文件. 当获取到本地文件的修改时间时, 此功能将使用用户提供的文件名 (参见 --out 选项), 如果没有指定 --out 选项则使用 URI 中的文件名. 为了覆盖已经存在的文件, 需要使用 --allow-overwrite 参数.",
						"conf-path.name": "配置文件路径",
						"conf-path.description": "",
						"console-log-level.name": "控制台日志级别",
						"console-log-level.description": "",
						"content-disposition-default-utf8.name": "使用 UTF-8 处理 Content-Disposition",
						"content-disposition-default-utf8.description": '处理 "Content-Disposition" 头中的字符串时使用 UTF-8 字符集来代替 ISO-8859-1, 例如, 文件名参数, 但不是扩展版本的文件名.',
						"daemon.name": "启用后台进程",
						"daemon.description": "",
						"deferred-input.name": "延迟加载",
						"deferred-input.description": '如果设置为"是", aria2 在启动时不会读取 --input-file 选项设置的文件中的所有 URI 地址, 而是会在之后需要时按需读取. 如果输入文件中包含大量要下载的 URI, 此选项可以减少内存的使用. 如果设置为"否", aria2 会在启动时读取所有的 URI. 当 -save-session 使用时将会禁用 --deferred-input 选项.',
						"disable-ipv6.name": "禁用 IPv6",
						"disable-ipv6.description": "",
						"disk-cache.name": "磁盘缓存",
						"disk-cache.description": "启用磁盘缓存. 如果设置为 0, 将禁用磁盘缓存. 此功能将下载的数据缓存在内存中, 最多占用此选项设置的字节数. 缓存存储由 aria2 实例创建并对所有下载共享. 由于数据以较大的单位写入并按文件的偏移重新排序, 所以磁盘缓存的一个优点是减少磁盘的 I/O. 如果调用哈希检查时并且数据缓存在内存中时, 将不需要从磁盘中读取. 大小可以包含 K 或 M (1K = 1024, 1M = 1024K).",
						"download-result.name": "下载结果",
						"download-result.description": '此选项将修改下载结果的格式. 如果设置为"默认", 将打印 GID, 状态, 平均下载速度和路径/URI. 如果涉及多个文件, 仅打印第一个请求文件的路径/URI, 其余的将被忽略. 如果设置为"完整", 将打印 GID, 状态, 平均下载速度, 下载进度和路径/URI. 其中, 下载进度和路径/URI 将会每个文件打印一行. 如果设置为"隐藏", 下载结果将会隐藏.',
						"dscp.name": "DSCP",
						"dscp.description": "为 QoS 设置 BT 上行 IP 包的 DSCP 值. 此参数仅设置 IP 包中 TOS 字段的 DSCP 位, 而不是整个字段. 如果您从 /usr/include/netinet/ip.h 得到的值, 需要除以 4 (否则值将不正确, 例如您的 CS1 类将会转为 CS4). 如果您从 RFC, 网络供应商的文档, 维基百科或其他来源采取常用的值, 可以直接使用.",
						"rlimit-nofile.name": "最多打开的文件描述符",
						"rlimit-nofile.description": "设置打开的文件描述符的软限制 (soft limit). 此选项仅当满足如下条件时开放: a. 系统支持它 (posix). b. 限制没有超过硬限制 (hard limit). c. 指定的限制比当前的软限制高. 这相当于设置 ulimit, 除了其不能降低限制. 此选项仅当系统支持 rlimit API 时有效.",
						"enable-color.name": "终端输出使用颜色",
						"enable-color.description": "",
						"enable-mmap.name": "启用 MMap",
						"enable-mmap.description": "内存中存放映射文件. 当文件空间没有预先分配至, 此选项无效. 参见 --file-allocation.",
						"event-poll.name": "事件轮询方法",
						"event-poll.description": "设置事件轮训的方法. 可选的值包括 epoll, kqueue, port, poll 和 select. 对于 epoll, kqueue, port 和 poll, 只有系统支持时才可用. 最新的 Linux 支持 epoll. 各种 *BSD 系统包括 Mac OS X 支持 kqueue. Open Solaris 支持 port. 默认值根据您使用的操作系统不同而不同.",
						"file-allocation.name": "文件分配方法",
						"file-allocation.description": '指定文件分配方法. "无" 不会预先分配文件空间. "prealloc"会在下载开始前预先分配空间. 这将会根据文件的大小需要一定的时间. 如果您使用的是较新的文件系统, 例如 ext4 (带扩展支持), btrfs, xfs 或 NTFS (仅 MinGW 构建), "falloc" 是最好的选择. 其几乎可以瞬间分配大(数 GiB)文件. 不要在旧的文件系统, 例如 ext3 和 FAT32 上使用 falloc, 因为与 prealloc 花费的时间相同, 并且其会阻塞 aria2 知道分配完成. 当您的系统不支持 posix_fallocate(3) 函数时, falloc 可能无法使用. "trunc" 使用 ftruncate(2) 系统调用或平台特定的实现将文件截取到特定的长度. 在多文件的 BitTorrent 下载中, 若某文件与其相邻的文件共享相同的分片时, 则相邻的文件也会被分配.',
						"force-save.name": "强制保存",
						"force-save.description": "即使任务完成或删除时使用 --save-session 选项时也保存该任务. 此选项在这种情况下还会保存控制文件. 此选项可以保存被认为已经完成但正在做种的 BT 任务.",
						"save-not-found.name": "保存未找到的文件",
						"save-not-found.description": "当使用 --save-session 选项时, 即使当任务中的文件不存在时也保存该下载任务. 此选项同时会将这种情况保存到控制文件中.",
						"hash-check-only.name": "仅哈希检查",
						"hash-check-only.description": '如果设置为"是", 哈希检查完使用 --check-integrity 选项, 根据是否下载完成决定是否终止下载.',
						"human-readable.name": "控制台可读输出",
						"human-readable.description": "在控制台输出可读格式的大小和速度 (例如, 1.2Ki, 3.4Mi).",
						"keep-unfinished-download-result.name": "保留未完成的任务",
						"keep-unfinished-download-result.description": "保留所有未完成的下载结果, 即使超过了 --max-download-result 选项设置的数量. 这将有助于在会话文件中保存所有的未完成的下载 (参考 --save-session 选项). 需要注意的是, 未完成任务的数量没有上限. 如果不希望这样, 请关闭此选项.",
						"max-download-result.name": "最多下载结果",
						"max-download-result.description": "设置内存中存储最多的下载结果数量. 下载结果包括已完成/错误/已删除的下载. 下载结果存储在一个先进先出的队列中, 因此其可以存储最多指定的下载结果的数量. 当队列已满且有新的下载结果创建时, 最老的下载结果将从队列的最前部移除, 新的将放在最后. 此选项设置较大的值后如果经过几千次的下载将导致较高的内存消耗. 设置为 0 表示不存储下载结果. 注意, 未完成的下载将始终保存在内存中, 不考虑该选项的设置. 参考 --keep-unfinished-download-result 选项.",
						"max-mmap-limit.name": "MMap 最大限制",
						"max-mmap-limit.description": "设置启用 MMap (参见 --enable-mmap 选项) 最大的文件大小. 文件大小由一个下载任务中所有文件大小的和决定. 例如, 如果一个下载包含 5 个文件, 那么文件大小就是这些文件的总大小. 如果文件大小超过此选项设置的大小时, MMap 将会禁用.",
						"max-resume-failure-tries.name": "最大断点续传尝试次数",
						"max-resume-failure-tries.description": '当 --always-resume 选项设置为"否"时, 如果 aria2 检测到有 N 个 URI 不支持断点续传时, 将从头开始下载文件. 如果 N 设置为 0, 当所有 URI 都不支持断点续传时才会从头下载文件. 参见 --always-resume 选项.',
						"min-tls-version.name": "最低 TLS 版本",
						"min-tls-version.description": "指定启用的最低 SSL/TLS 版本.",
						"log-level.name": "日志级别",
						"log-level.description": "",
						"optimize-concurrent-downloads.name": "优化并发下载",
						"optimize-concurrent-downloads.description": "根据可用带宽优化并发下载的数量. aria2 使用之前统计的下载速度通过规则 N = A + B Log10 (速度单位为 Mbps) 得到并发下载的数量. 其中系数 A 和 B 可以在参数中以冒号分隔自定义. 默认值 (A=5, B=25) 可以在 1Mbps 网络上使用通常 5 个并发下载, 在 100Mbps 网络上为 50 个. 并发下载的数量保持在 --max-concurrent-downloads 参数定义的最大之下.",
						"piece-length.name": "文件分片大小",
						"piece-length.description": "设置 HTTP/FTP 下载的分配大小. aria2 根据这个边界分割文件. 所有的分割都是这个长度的倍数. 此选项不适用于 BitTorrent 下载. 如果 Metalink 文件中包含分片哈希的结果此选项也不适用.",
						"show-console-readout.name": "显示控制台输出",
						"show-console-readout.description": "",
						"summary-interval.name": "下载摘要输出间隔",
						"summary-interval.description": "设置下载进度摘要的输出间隔(秒). 设置为 0 禁止输出.",
						"max-overall-download-limit.name": "全局最大下载速度",
						"max-overall-download-limit.description": "设置全局最大下载速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).",
						"max-download-limit.name": "最大下载速度",
						"max-download-limit.description": "设置每个任务的最大下载速度 (字节/秒). 0 表示不限制. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).",
						"no-conf.name": "禁用配置文件",
						"no-conf.description": "",
						"no-file-allocation-limit.name": "文件分配限制",
						"no-file-allocation-limit.description": "不对比此参数设置大小小的分配文件. 您可以增加数值的单位 K 或 M (1K = 1024, 1M = 1024K).",
						"parameterized-uri.name": "启用参数化 URI 支持",
						"parameterized-uri.description": "启用参数化 URI 支持. 您可以指定部分的集合: http://{sv1,sv2,sv3}/foo.iso. 同时您也可以使用步进计数器指定数字化的序列: http://host/image[000-100:2].img. 步进计数器可以省略. 如果所有 URI 地址不指向同样的文件, 例如上述第二个示例, 需要使用 -Z 选项.",
						"quiet.name": "禁用控制台输出",
						"quiet.description": "",
						"realtime-chunk-checksum.name": "实时数据块验证",
						"realtime-chunk-checksum.description": "如果提供了数据块的校验和, 将在下载过程中通过校验和验证数据块.",
						"remove-control-file.name": "删除控制文件",
						"remove-control-file.description": "在下载前删除控制文件. 使用 --allow-overwrite=true 选项时, 总是从头开始下载文件. 此选项将有助于使用不支持断点续传代理服务器的用户.",
						"save-session.name": "状态保存文件",
						"save-session.description": "当退出时保存错误及未完成的任务到指定的文件中. 您可以在重启 aria2 时使用 --input-file 选项重新加载. 如果您希望输出的内容使用 GZip 压缩, 您可以在文件名后增加 .gz 扩展名. 请注意, 通过 aria2.addTorrent() 和 aria2.addMetalink() RPC 方法添加的下载, 其元数据没有保存到文件的将不会保存. 通过 aria2.remove() 和 aria2.forceRemove() 删除的下载将不会保存.",
						"save-session-interval.name": "保存状态间隔",
						"save-session-interval.description": "每隔此选项设置的时间(秒)后会保存错误或未完成的任务到 --save-session 选项指定的文件中. 如果设置为 0, 仅当 aria2 退出时才会保存.",
						"socket-recv-buffer-size.name": "Socket 接收缓冲区大小",
						"socket-recv-buffer-size.description": "设置 Socket 接收缓冲区最大的字节数. 指定为 0 时将禁用此选项. 当使用 SO_RCVBUF 选项调用 setsockopt() 时此选项的值将设置到 Socket 的文件描述符中.",
						"stop.name": "自动关闭时间",
						"stop.description": "在此选项设置的时间(秒)后关闭应用. 如果设置为 0, 此功能将禁用.",
						"truncate-console-readout.name": "缩短控制台输出内容",
						"truncate-console-readout.description": "缩短控制台输出的内容在一行中."
					}
				};
				e.translations(t.defaultLanguage, a)
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").constant("aria2AllOptions", {
		dir: {
			type: "string",
			required: !0
		},
		log: {
			type: "string",
			required: !0
		},
		"max-concurrent-downloads": {
			type: "integer",
			defaultValue: "5",
			required: !0,
			min: 1
		},
		"check-integrity": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		continue: {
			type: "boolean",
			required: !0
		},
		"all-proxy": {
			type: "string"
		},
		"all-proxy-user": {
			type: "string"
		},
		"all-proxy-passwd": {
			type: "string"
		},
		"connect-timeout": {
			type: "integer",
			suffix: "Seconds",
			defaultValue: "60",
			required: !0,
			min: 1,
			max: 600
		},
		"dry-run": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"lowest-speed-limit": {
			type: "string",
			suffix: "Bytes",
			defaultValue: "0",
			required: !0,
			pattern: "^(0|[1-9]\\d*(K|M)?)$"
		},
		"max-connection-per-server": {
			type: "integer",
			defaultValue: "1",
			required: !0,
			min: 1,
			max: 16
		},
		"max-file-not-found": {
			type: "integer",
			defaultValue: "0",
			required: !0,
			min: 0
		},
		"max-tries": {
			type: "integer",
			defaultValue: "5",
			required: !0,
			min: 0
		},
		"min-split-size": {
			type: "string",
			suffix: "Bytes",
			defaultValue: "20M",
			required: !0,
			pattern: "^(0|[1-9]\\d*(K|M)?)$"
		},
		"netrc-path": {
			type: "string",
			readonly: !0,
			defaultValue: "$(HOME)/.netrc"
		},
		"no-netrc": {
			type: "boolean",
			required: !0
		},
		"no-proxy": {
			type: "text",
			split: ",",
			showCount: !0
		},
		out: {
			type: "string"
		},
		"proxy-method": {
			type: "option",
			options: ["get", "tunnel"],
			defaultValue: "get",
			required: !0
		},
		"remote-time": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"reuse-uri": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"retry-wait": {
			type: "integer",
			suffix: "Seconds",
			defaultValue: "0",
			required: !0,
			min: 0,
			max: 600
		},
		"server-stat-of": {
			type: "string"
		},
		"server-stat-timeout": {
			type: "integer",
			suffix: "Seconds",
			readonly: !0,
			defaultValue: "86400"
		},
		split: {
			type: "integer",
			defaultValue: "5",
			required: !0,
			min: 1
		},
		"stream-piece-selector": {
			type: "option",
			options: ["default", "inorder", "random", "geom"],
			defaultValue: "default",
			required: !0
		},
		timeout: {
			type: "integer",
			suffix: "Seconds",
			defaultValue: "60",
			required: !0,
			min: 1,
			max: 600
		},
		"uri-selector": {
			type: "option",
			options: ["inorder", "feedback", "adaptive"],
			defaultValue: "feedback",
			required: !0
		},
		"check-certificate": {
			type: "boolean",
			readonly: !0,
			defaultValue: "true"
		},
		"http-accept-gzip": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"http-auth-challenge": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"http-no-cache": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"http-user": {
			type: "string"
		},
		"http-passwd": {
			type: "string"
		},
		"http-proxy": {
			type: "string"
		},
		"http-proxy-user": {
			type: "string"
		},
		"http-proxy-passwd": {
			type: "string"
		},
		"https-proxy": {
			type: "string"
		},
		"https-proxy-user": {
			type: "string"
		},
		"https-proxy-passwd": {
			type: "string"
		},
		referer: {
			type: "string"
		},
		"enable-http-keep-alive": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"enable-http-pipelining": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		header: {
			type: "string"
		},
		"save-cookies": {
			type: "string"
		},
		"use-head": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"user-agent": {
			type: "string",
			defaultValue: "aria2/$VERSION"
		},
		"ftp-user": {
			type: "string",
			defaultValue: "anonymous"
		},
		"ftp-passwd": {
			type: "string",
			defaultValue: "ARIA2USER@"
		},
		"ftp-pasv": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"ftp-proxy": {
			type: "string"
		},
		"ftp-proxy-user": {
			type: "string"
		},
		"ftp-proxy-passwd": {
			type: "string"
		},
		"ftp-type": {
			type: "option",
			options: ["binary", "ascii"],
			defaultValue: "binary",
			required: !0
		},
		"ftp-reuse-connection": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"ssh-host-key-md": {
			type: "string"
		},
		"show-files": {
			type: "boolean",
			readonly: !0
		},
		"bt-detach-seed-only": {
			type: "boolean",
			readonly: !0,
			defaultValue: "false"
		},
		"bt-enable-hook-after-hash-check": {
			since: "1.19.3",
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"bt-enable-lpd": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"bt-exclude-tracker": {
			type: "text",
			split: ",",
			showCount: !0
		},
		"bt-external-ip": {
			type: "string"
		},
		"bt-force-encryption": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"bt-hash-check-seed": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"bt-max-open-files": {
			type: "integer",
			defaultValue: "100",
			required: !0,
			min: 1
		},
		"bt-max-peers": {
			type: "integer",
			defaultValue: "55",
			required: !0,
			min: 0
		},
		"bt-metadata-only": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"bt-min-crypto-level": {
			type: "option",
			options: ["plain", "arc4"],
			defaultValue: "plain",
			required: !0
		},
		"bt-prioritize-piece": {
			type: "string"
		},
		"bt-remove-unselected-file": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"bt-require-crypto": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"bt-request-peer-speed-limit": {
			type: "string",
			suffix: "Bytes",
			defaultValue: "50K",
			required: !0,
			pattern: "^(0|[1-9]\\d*(K|M)?)$"
		},
		"bt-save-metadata": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"bt-seed-unverified": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"bt-stop-timeout": {
			type: "integer",
			suffix: "Seconds",
			defaultValue: "0",
			required: !0,
			min: 0
		},
		"bt-tracker": {
			type: "text",
			split: ",",
			showCount: !0
		},
		"bt-tracker-connect-timeout": {
			type: "integer",
			suffix: "Seconds",
			defaultValue: "60",
			required: !0,
			min: 1,
			max: 600
		},
		"bt-tracker-interval": {
			type: "integer",
			suffix: "Seconds",
			defaultValue: "0",
			required: !0,
			min: 0
		},
		"bt-tracker-timeout": {
			type: "integer",
			suffix: "Seconds",
			defaultValue: "60",
			required: !0,
			min: 1,
			max: 600
		},
		"dht-file-path": {
			type: "string",
			readonly: !0,
			defaultValue: "$HOME/.aria2/dht.dat"
		},
		"dht-file-path6": {
			type: "string",
			readonly: !0,
			defaultValue: "$HOME/.aria2/dht6.dat"
		},
		"dht-listen-port": {
			type: "string",
			readonly: !0,
			defaultValue: "6881-6999"
		},
		"dht-message-timeout": {
			type: "integer",
			suffix: "Seconds",
			readonly: !0,
			defaultValue: "10"
		},
		"enable-dht": {
			type: "boolean",
			readonly: !0,
			defaultValue: "true"
		},
		"enable-dht6": {
			type: "boolean",
			readonly: !0
		},
		"enable-peer-exchange": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"follow-torrent": {
			type: "option",
			options: ["true", "false", "mem"],
			defaultValue: "true",
			required: !0
		},
		"listen-port": {
			type: "integer",
			readonly: !0,
			defaultValue: "6881-6999"
		},
		"max-overall-upload-limit": {
			type: "string",
			suffix: "Bytes",
			defaultValue: "0",
			required: !0,
			pattern: "^(0|[1-9]\\d*(K|M)?)$"
		},
		"max-upload-limit": {
			type: "string",
			suffix: "Bytes",
			defaultValue: "0",
			required: !0,
			pattern: "^(0|[1-9]\\d*(K|M)?)$"
		},
		"peer-id-prefix": {
			type: "string",
			readonly: !0,
			defaultValue: "A2-$MAJOR-$MINOR-$PATCH-"
		},
		"seed-ratio": {
			type: "float",
			defaultValue: "1.0",
			required: !0,
			min: 0
		},
		"seed-time": {
			type: "float",
			suffix: "Minutes",
			required: !0,
			min: 0
		},
		"follow-metalink": {
			type: "option",
			options: ["true", "false", "mem"],
			defaultValue: "true",
			required: !0
		},
		"metalink-base-uri": {
			type: "string"
		},
		"metalink-language": {
			type: "string"
		},
		"metalink-location": {
			type: "string"
		},
		"metalink-os": {
			type: "string"
		},
		"metalink-version": {
			type: "string"
		},
		"metalink-preferred-protocol": {
			type: "option",
			options: ["http", "https", "ftp", "none"],
			defaultValue: "none",
			required: !0
		},
		"metalink-enable-unique-protocol": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"enable-rpc": {
			type: "boolean",
			readonly: !0,
			defaultValue: "false"
		},
		"pause-metadata": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"rpc-allow-origin-all": {
			type: "boolean",
			readonly: !0,
			defaultValue: "false"
		},
		"rpc-listen-all": {
			type: "boolean",
			readonly: !0,
			defaultValue: "false"
		},
		"rpc-listen-port": {
			type: "integer",
			readonly: !0,
			defaultValue: "6800"
		},
		"rpc-max-request-size": {
			type: "string",
			suffix: "Bytes",
			readonly: !0,
			defaultValue: "2M"
		},
		"rpc-save-upload-metadata": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"rpc-secure": {
			type: "boolean",
			readonly: !0
		},
		"allow-overwrite": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"allow-piece-length-change": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"always-resume": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"async-dns": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"auto-file-renaming": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"auto-save-interval": {
			type: "integer",
			suffix: "Seconds",
			readonly: !0,
			defaultValue: "60"
		},
		"conditional-get": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"conf-path": {
			type: "string",
			readonly: !0,
			defaultValue: "$HOME/.aria2/aria2.conf"
		},
		"console-log-level": {
			type: "option",
			options: ["debug", "info", "notice", "warn", "error"],
			readonly: !0,
			defaultValue: "notice"
		},
		"content-disposition-default-utf8": {
			since: "1.31.0",
			type: "boolean",
			defaultValue: "false"
		},
		daemon: {
			type: "boolean",
			readonly: !0,
			defaultValue: "false"
		},
		"deferred-input": {
			type: "boolean",
			readonly: !0,
			defaultValue: "false"
		},
		"disable-ipv6": {
			type: "boolean",
			readonly: !0,
			defaultValue: "false"
		},
		"disk-cache": {
			type: "string",
			suffix: "Bytes",
			readonly: !0,
			defaultValue: "16M"
		},
		"download-result": {
			type: "option",
			options: ["default", "full", "hide"],
			defaultValue: "default",
			required: !0
		},
		dscp: {
			type: "string",
			readonly: !0
		},
		"rlimit-nofile": {
			type: "string",
			readonly: !0
		},
		"enable-color": {
			type: "boolean",
			readonly: !0,
			defaultValue: "true"
		},
		"enable-mmap": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"event-poll": {
			type: "option",
			options: ["epoll", "kqueue", "port", "poll", "select"],
			readonly: !0
		},
		"file-allocation": {
			type: "option",
			options: ["none", "prealloc", "trunc", "falloc"],
			defaultValue: "prealloc",
			required: !0
		},
		"force-save": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"save-not-found": {
			since: "1.27.0",
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"hash-check-only": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		"human-readable": {
			type: "boolean",
			readonly: !0,
			defaultValue: "true"
		},
		"keep-unfinished-download-result": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"max-download-result": {
			type: "integer",
			defaultValue: "1000",
			required: !0,
			min: 0
		},
		"max-mmap-limit": {
			since: "1.20.0",
			type: "string",
			suffix: "Bytes",
			defaultValue: "9223372036854775807",
			required: !0,
			pattern: "^(0|[1-9]\\d*(K|M)?)$"
		},
		"max-resume-failure-tries": {
			type: "integer",
			defaultValue: "0",
			required: !0,
			min: 0
		},
		"min-tls-version": {
			type: "option",
			options: ["SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2"],
			readonly: !0,
			defaultValue: "TLSv1"
		},
		"log-level": {
			type: "option",
			options: ["debug", "info", "notice", "warn", "error"],
			defaultValue: "debug",
			required: !0
		},
		"optimize-concurrent-downloads": {
			since: "1.22.0",
			type: "string",
			defaultValue: "false"
		},
		"piece-length": {
			type: "string",
			suffix: "Bytes",
			defaultValue: "1M",
			required: !0,
			pattern: "^(0|[1-9]\\d*M?)$"
		},
		"show-console-readout": {
			type: "boolean",
			readonly: !0,
			defaultValue: "true"
		},
		"summary-interval": {
			type: "integer",
			suffix: "Seconds",
			readonly: !0,
			defaultValue: "60"
		},
		"max-overall-download-limit": {
			type: "string",
			suffix: "Bytes",
			defaultValue: "0",
			required: !0,
			pattern: "^(0|[1-9]\\d*(K|M)?)$"
		},
		"max-download-limit": {
			type: "string",
			suffix: "Bytes",
			defaultValue: "0",
			required: !0,
			pattern: "^(0|[1-9]\\d*(K|M)?)$"
		},
		"no-conf": {
			type: "boolean",
			readonly: !0
		},
		"no-file-allocation-limit": {
			type: "string",
			suffix: "Bytes",
			defaultValue: "5M",
			required: !0,
			pattern: "^(0|[1-9]\\d*(K|M)?)$"
		},
		"parameterized-uri": {
			type: "boolean",
			defaultValue: "false",
			required: !0
		},
		quiet: {
			type: "boolean",
			readonly: !0,
			defaultValue: "false"
		},
		"realtime-chunk-checksum": {
			type: "boolean",
			defaultValue: "true",
			required: !0
		},
		"remove-control-file": {
			type: "boolean",
			required: !0
		},
		"save-session": {
			type: "string"
		},
		"save-session-interval": {
			type: "integer",
			suffix: "Seconds",
			readonly: !0,
			defaultValue: "0"
		},
		"socket-recv-buffer-size": {
			since: "1.19.3",
			type: "string",
			suffix: "Bytes",
			readonly: !0,
			defaultValue: "0"
		},
		stop: {
			type: "integer",
			suffix: "Seconds",
			readonly: !0,
			defaultValue: "0"
		},
		"truncate-console-readout": {
			type: "boolean",
			readonly: !0,
			defaultValue: "true"
		}
	}).constant("aria2GlobalAvailableOptions", {
		basicOptions: ["dir", "log", "max-concurrent-downloads", "check-integrity", "continue"],
		httpFtpSFtpOptions: ["all-proxy", "all-proxy-user", "all-proxy-passwd", "connect-timeout", "dry-run", "lowest-speed-limit", "max-connection-per-server", "max-file-not-found", "max-tries", "min-split-size", "netrc-path", "no-netrc", "no-proxy", "proxy-method", "remote-time", "reuse-uri", "retry-wait", "server-stat-of", "server-stat-timeout", "split", "stream-piece-selector", "timeout", "uri-selector"],
		httpOptions: ["check-certificate", "http-accept-gzip", "http-auth-challenge", "http-no-cache", "http-user", "http-passwd", "http-proxy", "http-proxy-user", "http-proxy-passwd", "https-proxy", "https-proxy-user", "https-proxy-passwd", "referer", "enable-http-keep-alive", "enable-http-pipelining", "header", "save-cookies", "use-head", "user-agent"],
		ftpSFtpOptions: ["ftp-user", "ftp-passwd", "ftp-pasv", "ftp-proxy", "ftp-proxy-user", "ftp-proxy-passwd", "ftp-type", "ftp-reuse-connection", "ssh-host-key-md"],
		btOptions: ["bt-detach-seed-only", "bt-enable-hook-after-hash-check", "bt-enable-lpd", "bt-exclude-tracker", "bt-external-ip", "bt-force-encryption", "bt-hash-check-seed", "bt-max-open-files", "bt-max-peers", "bt-metadata-only", "bt-min-crypto-level", "bt-prioritize-piece", "bt-remove-unselected-file", "bt-require-crypto", "bt-request-peer-speed-limit", "bt-save-metadata", "bt-seed-unverified", "bt-stop-timeout", "bt-tracker", "bt-tracker-connect-timeout", "bt-tracker-interval", "bt-tracker-timeout", "dht-file-path", "dht-file-path6", "dht-listen-port", "dht-message-timeout", "enable-dht", "enable-dht6", "enable-peer-exchange", "follow-torrent", "listen-port", "max-overall-upload-limit", "max-upload-limit", "peer-id-prefix", "seed-ratio", "seed-time"],
		metalinkOptions: ["follow-metalink", "metalink-base-uri", "metalink-language", "metalink-location", "metalink-os", "metalink-version", "metalink-preferred-protocol", "metalink-enable-unique-protocol"],
		rpcOptions: ["enable-rpc", "pause-metadata", "rpc-allow-origin-all", "rpc-listen-all", "rpc-listen-port", "rpc-max-request-size", "rpc-save-upload-metadata", "rpc-secure"],
		advancedOptions: ["allow-overwrite", "allow-piece-length-change", "always-resume", "async-dns", "auto-file-renaming", "auto-save-interval", "conditional-get", "conf-path", "console-log-level", "content-disposition-default-utf8", "daemon", "deferred-input", "disable-ipv6", "disk-cache", "download-result", "dscp", "rlimit-nofile", "enable-color", "enable-mmap", "event-poll", "file-allocation", "force-save", "save-not-found", "hash-check-only", "human-readable", "keep-unfinished-download-result", "max-download-result", "max-mmap-limit", "max-resume-failure-tries", "min-tls-version", "log-level", "optimize-concurrent-downloads", "piece-length", "show-console-readout", "summary-interval", "max-overall-download-limit", "max-download-limit", "no-conf", "no-file-allocation-limit", "parameterized-uri", "quiet", "realtime-chunk-checksum", "remove-control-file", "save-session", "save-session-interval", "socket-recv-buffer-size", "stop", "truncate-console-readout"]
	}).constant("aria2QuickSettingsAvailableOptions", {
		globalSpeedLimitOptions: ["max-overall-download-limit", "max-overall-upload-limit"]
	}).constant("aria2TaskAvailableOptions", {
		taskOptions: [{
				key: "dir",
				category: "global",
				canUpdate: "new"
			}, {
				key: "out",
				category: "http",
				canUpdate: "new"
			}, {
				key: "allow-overwrite",
				category: "global",
				canShow: "new"
			}, {
				key: "max-download-limit",
				category: "global"
			}, {
				key: "max-upload-limit",
				category: "bittorrent"
			}, {
				key: "split",
				category: "http",
				canUpdate: "new|waiting|paused"
			}, {
				key: "min-split-size",
				category: "http",
				canUpdate: "new|waiting|paused"
			}, {
				key: "max-connection-per-server",
				category: "http",
				canUpdate: "new|waiting|paused"
			}, {
				key: "lowest-speed-limit",
				category: "http",
				canUpdate: "new|waiting|paused"
			}, {
				key: "stream-piece-selector",
				category: "http",
				canUpdate: "new|waiting|paused"
			}, {
				key: "all-proxy",
				category: "http",
				canUpdate: "new|waiting|paused"
			}, {
				key: "all-proxy-user",
				category: "http",
				canUpdate: "new|waiting|paused"
			}, {
				key: "all-proxy-passwd",
				category: "http",
				canUpdate: "new|waiting|paused"
			}, {
				key: "header",
				category: "http",
				canUpdate: "new"
			}, {
				key: "bt-max-peers",
				category: "bittorrent"
			}, {
				key: "bt-request-peer-speed-limit",
				category: "bittorrent"
			}, {
				key: "bt-remove-unselected-file",
				category: "bittorrent"
			}, {
				key: "bt-stop-timeout",
				category: "bittorrent",
				canUpdate: "new|waiting|paused"
			}, {
				key: "bt-tracker",
				category: "bittorrent",
				canUpdate: "new|waiting|paused"
			}, {
				key: "seed-ratio",
				category: "bittorrent",
				canUpdate: "new|waiting|paused"
			}, {
				key: "seed-time",
				category: "bittorrent",
				canUpdate: "new|waiting|paused"
			}, {
				key: "conditional-get",
				category: "global",
				canShow: "new"
			}, {
				key: "file-allocation",
				category: "global",
				canShow: "new"
			}, {
				key: "parameterized-uri",
				category: "global",
				canShow: "new"
			}, {
				key: "force-save",
				category: "global"
			}
		]
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").constant("aria2Errors", {
		1: {
			descriptionKey: "error.unknown"
		},
		2: {
			descriptionKey: "error.operation.timeout"
		},
		3: {
			descriptionKey: "error.resource.notfound"
		},
		4: {
			descriptionKey: "error.resource.notfound.max-file-not-found"
		},
		5: {
			descriptionKey: "error.download.aborted.lowest-speed-limit"
		},
		6: {
			descriptionKey: "error.network.problem"
		},
		8: {
			descriptionKey: "error.resume.notsupported"
		},
		9: {
			descriptionKey: "error.space.notenough"
		},
		10: {
			descriptionKey: "error.piece.length.different"
		},
		11: {
			descriptionKey: "error.download.sametime"
		},
		12: {
			descriptionKey: "error.download.torrent.sametime"
		},
		13: {
			descriptionKey: "error.file.exists"
		},
		14: {
			descriptionKey: "error.file.rename.failed"
		},
		15: {
			descriptionKey: "error.file.open.failed"
		},
		16: {
			descriptionKey: "error.file.create.failed"
		},
		17: {
			descriptionKey: "error.io.error"
		},
		18: {
			descriptionKey: "error.directory.create.failed"
		},
		19: {
			descriptionKey: "error.name.resolution.failed"
		},
		20: {
			descriptionKey: "error.metalink.file.parse.failed"
		},
		21: {
			descriptionKey: "error.ftp.command.failed"
		},
		22: {
			descriptionKey: "error.http.response.header.bad"
		},
		23: {
			descriptionKey: "error.redirects.toomany"
		},
		24: {
			descriptionKey: "error.http.authorization.failed"
		},
		25: {
			descriptionKey: "error.bencoded.file.parse.failed"
		},
		26: {
			descriptionKey: "error.torrent.file.corrupted"
		},
		27: {
			descriptionKey: "error.magnet.uri.bad"
		},
		28: {
			descriptionKey: "error.option.bad"
		},
		29: {
			descriptionKey: "error.server.overload"
		},
		30: {
			descriptionKey: "error.rpc.request.parse.failed"
		},
		32: {
			descriptionKey: "error.checksum.failed"
		}
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").constant("aria2RpcConstants", {
		rpcServiceVersion: "2.0",
		rpcServiceName: "aria2",
		rpcSystemServiceName: "system",
		rpcTokenPrefix: "token:"
	}).constant("aria2RpcErrors", {
		Unauthorized: {
			message: "Unauthorized",
			tipTextKey: "rpc.error.unauthorized"
		}
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").controller("CommandController", ["$rootScope", "$window", "$location", "$routeParams", "base64", "ariaNgDefaultOptions", "ariaNgCommonService", "ariaNgSettingService", "aria2TaskService", "ariaNgLogService", function (e, t, a, n, i, s, o, r, l, c) {
				var d = a.path(),
				u = function (t) {
					try {
						t = i.urldecode(t)
					} catch (e) {
						return o.showError("URL is not base64 encoded!"),
						!1
					}
					return e.loadPromise = l.newUriTask({
							urls: [t],
							options: {}
						}, !1, function (e) {
							if (!e.success)
								return !1;
							a.path("/downloading")
						}),
					c.info("[CommandController] new download: " + t),
					!0
				},
				p = function (e, n, l, d, u) {
					if (l = l || s.rpcPort, d = d || s.rpcInterface, u = u || s.secret, c.info("[CommandController] set rpc: " + e + "://" + n + ":" + l + "/" + d + ", secret: " + u), !e || "http" !== e && "https" !== e && "ws" !== e && "wss" !== e)
						return o.showError("Protocol is invalid!"), !1;
					if (!n)
						return o.showError("RPC host cannot be empty!"), !1;
					if (u)
						try {
							u = i.urldecode(u)
						} catch (e) {
							return o.showError("RPC secret is not base64 encoded!"),
							!1
						}
					var p = {
						rpcAlias: "",
						rpcHost: n,
						rpcPort: l,
						rpcInterface: d,
						protocol: e,
						httpMethod: s.httpMethod,
						secret: u
					};
					return r.isRpcSettingEqualsDefault(p) ? a.path("/downloading") : (r.setDefaultRpcSetting(p, {
							keepCurrent: !1,
							forceSet: !0
						}), a.path("/downloading"), t.location.reload()),
					!0
				};
				(function (e, t) {
					return 0 === e.indexOf("/new/") ? u(t.url) : 0 === e.indexOf("/settings/rpc/set/") ? p(t.protocol, t.host, t.port, t.interface, t.secret) : (o.showError("Parameter is invalid!"), !1)
				})(d, n) || a.path("/downloading")
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").controller("MainController", ["$rootScope", "$scope", "$route", "$window", "$location", "$document", "$interval", "aria2RpcErrors", "ariaNgCommonService", "ariaNgSettingService", "ariaNgTitleService", "ariaNgMonitorService", "ariaNgNotificationService", "aria2TaskService", "aria2SettingService", function (e, t, a, n, i, s, o, r, l, c, d, u, p, f, g) {
				var m = null,
				h = null,
				v = function () {
					s[0].title = d.getFinalTitleByGlobalStat(t.globalStat)
				},
				b = function (e, a) {
					return g.getGlobalStat(function (e) {
						if (!e.success && e.data.message === r.Unauthorized.message)
							return void o.cancel(h);
						e.success && (t.globalStat = e.data, u.recordGlobalStat(e.data)),
						a && a(e)
					}, e)
				};
				c.getBrowserNotification() && p.requestBrowserPermission(),
				t.globalStatusContext = {
					isEnabled: c.getGlobalStatRefreshInterval() > 0,
					data: u.getGlobalStatsData()
				},
				t.quickSettingContext = null,
				t.rpcSettings = c.getAllRpcSettings(),
				t.isTaskSelected = function () {
					return e.taskContext.getSelectedTaskIds().length > 0
				},
				t.isSpecifiedTaskSelected = function () {
					var t = e.taskContext.getSelectedTasks();
					if (t.length < 1)
						return !1;
					for (var a = 0; a < t.length; a++)
						for (var n = 0; n < arguments.length; n++)
							if (t[a].status === arguments[n])
								return !0;
					return !1
				},
				t.isSpecifiedTaskShowing = function () {
					var t = e.taskContext.list;
					if (t.length < 1)
						return !1;
					for (var a = 0; a < t.length; a++)
						for (var n = 0; n < arguments.length; n++)
							if (t[a].status === arguments[n])
								return !0;
					return !1
				},
				t.changeTasksState = function (t) {
					var n = e.taskContext.getSelectedTaskIds();
					if (n && !(n.length < 1)) {
						var s = null;
						if ("start" === t)
							s = f.startTasks;
						else {
							if ("pause" !== t)
								return;
							s = f.pauseTasks
						}
						e.loadPromise = s(n, function (e) {
								e.hasError && n.length > 1 && l.showError("Failed to change some tasks state."),
								e.hasSuccess && (b(!0), e.hasError || "start" !== t ? e.hasError || "pause" !== t || ("/downloading" === i.path() ? i.path("/waiting") : a.reload()) : "/waiting" === i.path() ? i.path("/downloading") : a.reload())
							}, n.length > 1)
					}
				},
				t.restart = function (t) {
					l.confirm("Confirm Restart", "Are you sure you want to restart this task? AriaNg will create a same task after clicking OK.", "info", function () {
						e.loadPromise = f.restartTask(t.gid, function (e) {
								if (!e.success)
									return void l.showError("Failed to restart this task.");
								b(!0),
								e.success && ("/downloading" !== i.path() ? i.path("/downloading") : a.reload())
							}, !1)
					})
				},
				t.removeTasks = function () {
					var t = e.taskContext.getSelectedTasks();
					!t || t.length < 1 || l.confirm("Confirm Remove", "Are you sure you want to remove the selected task?", "warning", function () {
						e.loadPromise = f.removeTasks(t, function (e) {
								e.hasError && t.length > 1 && l.showError("Failed to remove some task(s)."),
								e.hasSuccess && (b(!0), e.hasError || ("/stopped" !== i.path() ? i.path("/stopped") : a.reload()))
							}, t.length > 1)
					})
				},
				t.clearStoppedTasks = function () {
					l.confirm("Confirm Clear", "Are you sure you want to clear stopped tasks?", "warning", function () {
						e.loadPromise = f.clearStoppedTasks(function (e) {
								e.success && (b(!0), "/stopped" !== i.path() ? i.path("/stopped") : a.reload())
							})
					})
				},
				t.selectAllTasks = function () {
					e.taskContext.selectAll()
				},
				t.changeDisplayOrder = function (e, t) {
					var a = l.parseOrderType(c.getDisplayOrder()),
					n = l.parseOrderType(e);
					t && n.type === a.type && (n.reverse = !a.reverse),
					c.setDisplayOrder(n.getValue())
				},
				t.isSetDisplayOrder = function (e) {
					var t = l.parseOrderType(c.getDisplayOrder()),
					a = l.parseOrderType(e);
					return t.equals(a)
				},
				t.showQuickSettingDialog = function (e, a) {
					t.quickSettingContext = {
						type: e,
						title: a
					}
				},
				t.switchRpcSetting = function (e) {
					e.isDefault || (c.setDefaultRpcSetting(e), n.location.reload())
				},
				c.getTitleRefreshInterval() > 0 && (m = o(function () {
							v()
						}, c.getTitleRefreshInterval())),
				c.getGlobalStatRefreshInterval() > 0 && (h = o(function () {
							b(!0)
						}, c.getGlobalStatRefreshInterval())),
				t.$on("$destroy", function () {
					m && o.cancel(m),
					h && o.cancel(h)
				}),
				b(!0, function () {
					v()
				})
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").controller("NewTaskController", ["$rootScope", "$scope", "$location", "$timeout", "ariaNgCommonService", "ariaNgSettingService", "ariaNgFileService", "aria2SettingService", "aria2TaskService", function (e, t, a, n, i, s, o, r, l) {
				var c = ["links", "options"],
				d = function (e, a) {
					for (var n = t.context.urls.split("\n"), i = angular.copy(t.context.options), s = [], o = 0; o < n.length; o++)
						"" !== n[o] && "" !== n[o].trim() && s.push({
							urls: [n[o].trim()],
							options: i
						});
					return l.newUriTasks(s, e, a)
				},
				u = function (e, a) {
					var n = {
						content: t.context.uploadFile.base64Content,
						options: angular.copy(t.context.options)
					};
					return l.newTorrentTask(n, e, a)
				},
				p = function (e, a) {
					var n = {
						content: t.context.uploadFile.base64Content,
						options: angular.copy(t.context.options)
					};
					return l.newMetalinkTask(n, e, a)
				};
				t.context = {
					currentTab: "links",
					taskType: "urls",
					urls: "",
					uploadFile: null,
					availableOptions: function () {
						var e = r.getNewTaskOptionKeys();
						return r.getSpecifiedOptions(e, {
							disableRequired: !0
						})
					}
					(),
					globalOptions: null,
					options: {},
					optionFilter: {
						global: !0,
						http: !1,
						bittorrent: !1
					}
				},
				t.changeTab = function (e) {
					"options" === e && t.loadDefaultOption(),
					t.context.currentTab = e
				},
				e.swipeActions.extentLeftSwipe = function () {
					var e = c.indexOf(t.context.currentTab);
					return e < c.length - 1 && (t.changeTab(c[e + 1]), !0)
				},
				e.swipeActions.extentRightSwipe = function () {
					var e = c.indexOf(t.context.currentTab);
					return e > 0 && (t.changeTab(c[e - 1]), !0)
				},
				t.loadDefaultOption = function () {
					t.context.globalOptions || (e.loadPromise = r.getGlobalOption(function (e) {
								e.success && (t.context.globalOptions = e.data)
							}))
				},
				t.openTorrent = function () {
					o.openFileContent(".torrent", function (e) {
						t.context.uploadFile = e,
						t.context.taskType = "torrent",
						t.changeTab("options")
					}, function (e) {
						i.showError(e)
					})
				},
				t.openMetalink = function () {
					o.openFileContent(".meta4,.metalink", function (e) {
						t.context.uploadFile = e,
						t.context.taskType = "metalink",
						t.changeTab("options")
					}, function (e) {
						i.showError(e)
					})
				},
				t.startDownload = function (n) {
					var i = function (e) {
						if (e.hasSuccess || e.success) {
							var t = null;
							e.results && e.results.length > 0 ? t = e.results[0] : e && (t = e),
							"task-detail" === s.getAfterCreatingNewTask() && t && t.data ? a.path("/task/detail/" + t.data) : n ? a.path("/waiting") : a.path("/downloading")
						}
					};
					"urls" === t.context.taskType ? e.loadPromise = d(n, i) : "torrent" === t.context.taskType ? e.loadPromise = u(n, i) : "metalink" === t.context.taskType && (e.loadPromise = p(n, i))
				},
				t.setOption = function (e, a, n) {
					"" !== a ? t.context.options[e] = a : delete t.context.options[e],
					n.setReady()
				},
				t.urlTextboxKeyDown = function (e) {
					13 === e.keyCode && e.ctrlKey && t.newTaskForm.$valid && t.startDownload()
				},
				e.loadPromise = n(function () {}, 100)
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").controller("DownloadListController", ["$rootScope", "$scope", "$window", "$location", "$route", "$interval", "dragulaService", "aria2RpcErrors", "ariaNgCommonService", "ariaNgSettingService", "aria2TaskService", function (e, t, a, n, i, s, o, r, l, c, d) {
				var u = n.path().substring(1),
				p = null,
				f = !1,
				g = !0,
				m = function (t) {
					if (!f)
						return d.getTaskList(u, g, function (t) {
							if (!f) {
								if (!t.success)
									return void(t.data.message === r.Unauthorized.message && s.cancel(p));
								var a = t.context.requestWholeInfo,
								n = t.data;
								if (a ? (e.taskContext.list = n, g = !1) : g = !l.extendArray(n, e.taskContext.list, "gid"), e.taskContext.list && e.taskContext.list.length > 0 && (d.processDownloadTasks(e.taskContext.list), !a)) {
									for (var i = !1, o = 0; o < e.taskContext.list.length; o++) {
										var c = e.taskContext.list[o];
										if (c.hasTaskName || c.files || c.bittorrent) {
											i = !0;
											break
										}
									}
									if (!i)
										return g = !0, void(e.taskContext.list.length = 0)
								}
								e.taskContext.enableSelectAll = e.taskContext.list && e.taskContext.list.length > 0
							}
						}, t)
				};
				t.filterByTaskName = function (t) {
					return !(!t || !angular.isString(t.taskName)) && (!e.searchContext || !e.searchContext.text || t.taskName.toLowerCase().indexOf(e.searchContext.text.toLowerCase()) >= 0)
				},
				t.getOrderType = function () {
					return c.getDisplayOrder()
				},
				t.isSupportDragTask = function () {
					var e = l.parseOrderType(c.getDisplayOrder());
					return "waiting" === u && "default" === e.type
				},
				c.getDownloadTaskRefreshInterval() > 0 && (p = s(function () {
							m(!0)
						}, c.getDownloadTaskRefreshInterval())),
				o.options(t, "task-list", {
					revertOnSpill: !0,
					moves: function () {
						return t.isSupportDragTask()
					}
				}),
				t.$on("task-list.drop-model", function (e, t, a) {
					var n = angular.element(t),
					i = n.attr("data-gid"),
					s = n.index();
					f = !0,
					d.changeTaskPosition(i, s, function () {
						f = !1
					}, !0)
				}),
				t.$on("$destroy", function () {
					f = !0,
					p && s.cancel(p)
				}),
				e.loadPromise = m(!1)
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").controller("TaskDetailController", ["$rootScope", "$scope", "$routeParams", "$interval", "aria2RpcErrors", "ariaNgFileTypes", "ariaNgCommonService", "ariaNgSettingService", "ariaNgMonitorService", "aria2TaskService", "aria2SettingService", function (e, t, a, n, i, s, o, r, l, c, d) {
				var u = ["overview", "blocks", "filelist", "btpeers"],
				p = null,
				f = !1,
				g = function (e, t) {
					var a = d.getAvailableTaskOptionKeys(e, t);
					return d.getSpecifiedOptions(a, {
						disableRequired: !0
					})
				},
				m = function (a) {
					a && ("active" === a.status && a.bittorrent || u.indexOf("btpeers") >= 0 && u.splice(u.indexOf("btpeers"), 1), t.task && t.task.status === a.status || (t.context.availableOptions = g(a.status, !!a.bittorrent)), t.task = o.copyObjectTo(a, t.task), e.taskContext.list = [t.task], e.taskContext.selected = {}, e.taskContext.selected[t.task.gid] = !0, l.recordStat(a.gid, a))
				},
				h = function (e) {
					e && (o.extendArray(e, t.context.btPeers, "peerId") || (t.context.btPeers = e), t.context.healthPercent = c.estimateHealthPercentFromPeers(t.task, t.context.btPeers))
				},
				v = function (e) {
					return e && e.bittorrent && "active" === e.status
				},
				b = function (e) {
					if (!f) {
						var i = function (e) {
							n.cancel(p)
						};
						return t.task ? c.getTaskStatusAndBtPeers(a.gid, function (e) {
							if (!e.success)
								return i(e.data.message);
							m(e.task),
							h(e.peers)
						}, e, v(t.task), !0) : c.getTaskStatus(a.gid, function (t) {
							if (!t.success)
								return i(t.data.message);
							var a = t.data;
							m(a),
							v(a) && c.getBtTaskPeers(a, function (e) {
								e.success && h(e.data)
							}, e, !0)
						}, e)
					}
				},
				y = function (e) {
					if (t.task && t.task.files) {
						for (var a = t.task.gid, n = [], i = 0; i < t.task.files.length; i++) {
							var s = t.task.files[i];
							s && s.selected && n.push(s.index)
						}
						return f = !0,
						c.selectTaskFile(a, n, function (e) {
							f = !1,
							e.success && b(!1)
						}, e)
					}
				};
				t.context = {
					currentTab: "overview",
					isEnableSpeedChart: r.getDownloadTaskRefreshInterval() > 0,
					showChooseFilesToolbar: !1,
					btPeers: [],
					healthPercent: 0,
					collapseTrackers: !0,
					statusData: l.getEmptyStatsData(a.gid),
					availableOptions: [],
					options: []
				},
				t.changeTab = function (e) {
					"settings" === e && t.loadTaskOption(t.task),
					t.context.currentTab = e
				},
				e.swipeActions.extentLeftSwipe = function () {
					var e = u.indexOf(t.context.currentTab);
					return e < u.length - 1 && (t.changeTab(u[e + 1]), !0)
				},
				e.swipeActions.extentRightSwipe = function () {
					var e = u.indexOf(t.context.currentTab);
					return e > 0 && (t.changeTab(u[e - 1]), !0)
				},
				t.changeFileListDisplayOrder = function (e, t) {
					var a = o.parseOrderType(r.getFileListDisplayOrder()),
					n = o.parseOrderType(e);
					t && n.type === a.type && (n.reverse = !a.reverse),
					r.setFileListDisplayOrder(n.getValue())
				},
				t.isSetFileListDisplayOrder = function (e) {
					var t = o.parseOrderType(r.getFileListDisplayOrder()),
					a = o.parseOrderType(e);
					return t.equals(a)
				},
				t.getFileListOrderType = function () {
					return r.getFileListDisplayOrder()
				},
				t.showChooseFilesToolbar = function () {
					f = !0,
					t.context.showChooseFilesToolbar = !0
				},
				t.getSelectedFileCount = function () {
					for (var e = 0, a = 0; a < t.task.files.length; a++)
						e += t.task.files[a].selected ? 1 : 0;
					return e
				},
				t.selectFiles = function (e) {
					if (t.task && t.task.files)
						for (var a = 0; a < t.task.files.length; a++)
							"all" === e ? t.task.files[a].selected = !0 : "none" === e ? t.task.files[a].selected = !1 : "reverse" === e && (t.task.files[a].selected = !t.task.files[a].selected)
				},
				t.chooseSpecifiedFiles = function (e) {
					if (t.task && t.task.files && s[e]) {
						for (var a = s[e], n = [], i = !0, r = 0; r < t.task.files.length; r++) {
							var l = o.getFileExtension(t.task.files[r].fileName);
							l && (l = l.toLowerCase()),
							a.indexOf(l) >= 0 && (n.push(r), t.task.files[r].selected || (i = !1))
						}
						for (var r = 0; r < n.length; r++) {
							var c = n[r];
							t.task.files[c].selected = !i
						}
					}
				},
				t.saveChoosedFiles = function () {
					t.context.showChooseFilesToolbar && (e.loadPromise = y(!1), t.context.showChooseFilesToolbar = !1)
				},
				t.cancelChooseFiles = function () {
					t.context.showChooseFilesToolbar && (f = !1, b(!0), t.context.showChooseFilesToolbar = !1)
				},
				t.setSelectedFile = function () {
					t.context.showChooseFilesToolbar || y(!0)
				},
				t.changePeerListDisplayOrder = function (e, t) {
					var a = o.parseOrderType(r.getPeerListDisplayOrder()),
					n = o.parseOrderType(e);
					t && n.type === a.type && (n.reverse = !a.reverse),
					r.setPeerListDisplayOrder(n.getValue())
				},
				t.isSetPeerListDisplayOrder = function (e) {
					var t = o.parseOrderType(r.getPeerListDisplayOrder()),
					a = o.parseOrderType(e);
					return t.equals(a)
				},
				t.getPeerListOrderType = function () {
					return r.getPeerListDisplayOrder()
				},
				t.loadTaskOption = function (a) {
					e.loadPromise = c.getTaskOptions(a.gid, function (e) {
							e.success && (t.context.options = e.data)
						})
				},
				t.setOption = function (e, a, n) {
					return c.setTaskOption(t.task.gid, e, a, function (e) {
						e.success && "OK" === e.data ? n.setSuccess() : n.setFailed(e.data.message)
					}, !0)
				},
				r.getDownloadTaskRefreshInterval() > 0 && (p = n(function () {
							if (t.task && ("complete" === t.task.status || "error" === t.task.status || "removed" === t.task.status))
								return void n.cancel(p);
							b(!0)
						}, r.getDownloadTaskRefreshInterval())),
				t.$on("$destroy", function () {
					p && n.cancel(p)
				}),
				e.loadPromise = b(!1)
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").controller("AriaNgSettingsController", ["$rootScope", "$scope", "$routeParams", "$window", "$interval", "$timeout", "ariaNgLanguages", "ariaNgCommonService", "ariaNgSettingService", "ariaNgMonitorService", "ariaNgNotificationService", "ariaNgTitleService", function (e, t, a, n, i, s, o, r, l, c, d, u) {
				var p = a.extendType,
				f = null,
				g = function () {
					return u.getFinalTitleByGlobalStat(c.getCurrentGlobalStat())
				},
				m = function () {
					if (!f) {
						var t = e.$new();
						t.refreshPage = function () {
							n.location.reload()
						},
						f = d.notifyInPage("", "Configuration has been modified, please reload the page for the changes to take effect.", {
								delay: !1,
								type: "info",
								templateUrl: "setting-changed-notification.html",
								scope: t,
								onClose: function () {
									f = null
								}
							})
					}
				};
				t.context = {
					currentTab: "global",
					languages: o,
					titlePreview: g(),
					availableTime: r.getTimeOptions([1e3, 2e3, 3e3, 5e3, 1e4, 3e4, 6e4], !0),
					trueFalseOptions: [{
							name: "True",
							value: !0
						}, {
							name: "False",
							value: !1
						}
					],
					showRpcSecret: !1,
					settings: l.getAllOptions(),
					sessionSettings: l.getAllSessionOptions(),
					rpcSettings: l.getAllRpcSettings()
				},
				t.context.showDebugMode = t.context.sessionSettings.debugMode || "debug" === p,
				t.changeGlobalTab = function () {
					t.context.currentTab = "global"
				},
				t.isCurrentGlobalTab = function () {
					return "global" === t.context.currentTab
				},
				t.changeRpcTab = function (e) {
					t.context.currentTab = "rpc" + e
				},
				t.isCurrentRpcTab = function (e) {
					return t.context.currentTab === "rpc" + e
				},
				t.updateTitlePreview = function () {
					t.context.titlePreview = g()
				},
				e.swipeActions.extentLeftSwipe = function () {
					var e = -1;
					return t.isCurrentGlobalTab() || (e = parseInt(t.context.currentTab.substring(3))),
					e < t.context.rpcSettings.length - 1 && (t.changeRpcTab(e + 1), !0)
				},
				e.swipeActions.extentRightSwipe = function () {
					var e = -1;
					return t.isCurrentGlobalTab() || (e = parseInt(t.context.currentTab.substring(3))),
					e > 0 ? (t.changeRpcTab(e - 1), !0) : 0 === e && (t.changeGlobalTab(), !0)
				},
				t.setLanguage = function (e) {
					l.setLanguage(e),
					t.updateTitlePreview()
				},
				t.setAfterCreatingNewTask = function (e) {
					l.setAfterCreatingNewTask(e)
				},
				t.setDebugMode = function (e) {
					l.setDebugMode(e)
				},
				t.setTitle = function (e) {
					l.setTitle(e)
				},
				t.setTitleRefreshInterval = function (e) {
					m(),
					l.setTitleRefreshInterval(e)
				},
				t.isSupportNotification = function () {
					return d.isSupportBrowserNotification() && l.isCurrentRpcUseWebSocket(t.context.settings.protocol)
				},
				t.setEnableBrowserNotification = function (e) {
					l.setBrowserNotification(e),
					e && !d.hasBrowserPermission() && d.requestBrowserPermission(function (e) {
						d.isPermissionGranted(e) || (t.context.settings.browserNotification = !1, r.showError("You have disabled notification in your browser. You should change your browser's settings before you enable this function."))
					})
				},
				t.setGlobalStatRefreshInterval = function (e) {
					m(),
					l.setGlobalStatRefreshInterval(e)
				},
				t.setDownloadTaskRefreshInterval = function (e) {
					m(),
					l.setDownloadTaskRefreshInterval(e)
				},
				t.addNewRpcSetting = function () {
					m();
					var e = l.addNewRpcSetting();
					t.context.rpcSettings.push(e),
					t.changeRpcTab(t.context.rpcSettings.length - 1)
				},
				t.updateRpcSetting = function (e, t) {
					m(),
					l.updateRpcSetting(e, t)
				},
				t.removeRpcSetting = function (e) {
					var a = e.rpcAlias ? e.rpcAlias : e.rpcHost + ":" + e.rpcPort;
					r.confirm("Confirm Remove", 'Are you sure you want to remove rpc setting "{{rpcName}}"?', "warning", function () {
						m();
						var a = t.context.rpcSettings.indexOf(e);
						l.removeRpcSetting(e),
						t.context.rpcSettings.splice(a, 1),
						a >= t.context.rpcSettings.length && t.changeRpcTab(t.context.rpcSettings.length - 1)
					}, !1, {
						textParams: {
							rpcName: a
						}
					})
				},
				t.setDefaultRpcSetting = function (e) {
					e.isDefault || (l.setDefaultRpcSetting(e), n.location.reload())
				},
				$('[data-toggle="popover"]').popover(),
				e.loadPromise = s(function () {}, 100)
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").controller("Aria2SettingsController", ["$rootScope", "$scope", "$location", "ariaNgConstants", "ariaNgCommonService", "aria2SettingService", function (e, t, a, n, i, s) {
				var o = a.path().substring(a.path().lastIndexOf("/") + 1);
				t.context = {
					availableOptions: function (e) {
						var t = s.getAvailableGlobalOptionsKeys(e);
						return t ? s.getSpecifiedOptions(t) : void i.showError("Type is illegal!")
					}
					(o),
					globalOptions: []
				},
				t.setGlobalOption = function (e, t, a) {
					return s.setGlobalOption(e, t, function (e) {
						e.success && "OK" === e.data ? a.setSuccess() : a.setFailed(e.data.message)
					}, !0)
				},
				e.loadPromise = function () {
					return s.getGlobalOption(function (e) {
						e.success && (t.context.globalOptions = e.data)
					})
				}
				()
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").controller("Aria2StatusController", ["$rootScope", "$scope", "ariaNgCommonService", "ariaNgSettingService", "aria2SettingService", function (e, t, a, n, i) {
				t.context = {
					host: n.getCurrentRpcUrl(),
					status: "Connecting",
					serverStatus: null
				},
				t.saveSession = function () {
					return i.saveSession(function (e) {
						e.success && "OK" === e.data && a.showOperationSucceeded("Session has been saved successfully.")
					})
				},
				t.shutdown = function () {
					a.confirm("Confirm Shutdown", "Are you sure you want to shutdown aria2?", "warning", function (e) {
						return i.shutdown(function (e) {
							e.success && "OK" === e.data && a.showOperationSucceeded("Aria2 has been shutdown successfully.")
						})
					}, !0)
				},
				e.loadPromise = function () {
					return i.getAria2Status(function (e) {
						e.success ? (t.context.status = "Connected", t.context.serverStatus = e.data) : t.context.status = "Not Connected"
					})
				}
				()
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").directive("ngAutoFocus", ["$timeout", function (e) {
				return {
					restrict: "A",
					link: function (t, a) {
						e(function () {
							a[0].focus()
						})
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").directive("ngPieceBar", ["aria2TaskService", function (e) {
				return {
					restrict: "E",
					template: '<canvas class="piece-bar progress"></canvas>',
					replace: !0,
					scope: {
						bitField: "=",
						pieceCount: "=",
						color: "@"
					},
					link: function (t, a) {
						var n = function () {
							var n = a[0],
							i = e.getCombinedPieces(t.bitField, t.pieceCount),
							s = n.getContext("2d");
							s.fillStyle = t.color || "#000",
							s.clearRect(0, 0, n.width, n.height);
							for (var o = 0, r = n.width, l = n.height, c = 0; c < i.length; c++) {
								var d = i[c],
								u = d.count / t.pieceCount * r;
								d.isCompleted && s.fillRect(o, 0, u, l),
								o += u
							}
						};
						t.$watch("bitField", function () {
							n()
						}),
						t.$watch("pieceNumber", function () {
							n()
						})
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").directive("ngPieceMap", ["aria2TaskService", function (e) {
				return {
					restrict: "E",
					template: '<div class="piece-map"></div>',
					replace: !0,
					scope: {
						bitField: "=",
						pieceCount: "="
					},
					link: function (t, a) {
						var n = [],
						i = [],
						s = function () {
							i = e.getPieceStatus(t.bitField, t.pieceCount),
							n.length = 0,
							a.empty();
							for (var s = Math.max(1, i.length), o = 0; o < s; o++) {
								var r = angular.element('<div class="piece' + (i[o] ? " piece-completed" : "") + '"></div>');
								n.push(r),
								a.append(r)
							}
						},
						o = function () {
							var a = e.getPieceStatus(t.bitField, t.pieceCount);
							if (!i || !a || i.length !== a.length || a.length !== n.length)
								return void s();
							for (var o = 0; o < n.length; o++)
								i[o] !== a[o] && (a[o] ? n[o].addClass("piece-completed") : n[o].removeClass("piece-completed"));
							i = a
						};
						t.$watch("bitField", function () {
							o()
						}),
						t.$watch("pieceCount", function () {
							s()
						})
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").directive("ngChart", ["$window", "chartTheme", function (e, t) {
				return {
					restrict: "E",
					template: "<div></div>",
					scope: {
						options: "=ngData"
					},
					link: function (a, n, i) {
						var s = {
							ngTheme: "default"
						};
						angular.extend(s, i);
						var o = n.find("div"),
						r = n.parent(),
						l = r.height(),
						c = parseInt(i.height) || l || 200;
						o.css("height", c + "px");
						var d = echarts.init(o[0], t.get(s.ngTheme)),
						u = function (e) {
							d.setOption(e)
						};
						angular.element(e).on("resize", function () {
							d.resize(),
							a.$apply()
						}),
						a.$watch("options", function (e) {
							e && u(e)
						}, !0)
					}
				}
			}
		]).directive("ngPopChart", ["$window", "chartTheme", function (e, t) {
				return {
					restrict: "A",
					scope: {
						options: "=ngData"
					},
					link: function (e, a, n) {
						var i = {
							ngTheme: "default",
							ngPopoverClass: "",
							ngContainer: "body",
							ngTrigger: "click",
							ngPlacement: "top"
						};
						angular.extend(i, n);
						var s = null,
						o = '<div class="loading"><i class="fa fa-spinner fa-spin fa-2x"></i></div>';
						a.popover({
							container: i.ngContainer,
							content: '<div class="chart-pop-wrapper"><div class="chart-pop ' + i.ngPopoverClass + '">' + o + "</div></div>",
							html: !0,
							placement: i.ngPlacement,
							template: '<div class="popover chart-popover" role="tooltip"><div class="arrow"></div><div class="popover-content"></div></div>',
							trigger: i.ngTrigger
						}).on("shown.bs.popover", function () {
							var e = angular.element(".chart-pop"),
							a = e.parent(),
							o = a.height();
							e.empty();
							var r = parseInt(n.height) || o || 200;
							e.css("height", r + "px"),
							s = echarts.init(e[0], t.get(i.ngTheme))
						}).on("hide.bs.popover", function () {
							s && s.isDisposed() && s.dispose()
						}).on("hidden.bs.popover", function () {
							angular.element(".chart-pop").empty().append(o)
						});
						var r = function (e) {
							s && !s.isDisposed() && s.setOption(e)
						};
						e.$watch("options", function (e) {
							e && r(e)
						}, !0)
					}
				}
			}
		]).factory("chartTheme", ["chartDefaultTheme", function (e) {
				var t = {
					defaultTheme: e
				};
				return {
					get: function (e) {
						return t[e + "Theme"] ? t[e + "Theme"] : {}
					}
				}
			}
		]).factory("chartDefaultTheme", function () {
		return {
			color: ["#74a329", "#3a89e9"],
			legend: {
				top: "bottom"
			},
			toolbox: {
				show: !1
			},
			tooltip: {
				show: !0,
				trigger: "axis",
				backgroundColor: "rgba(0, 0, 0, 0.7)",
				axisPointer: {
					type: "line",
					lineStyle: {
						color: "#233333",
						type: "dashed",
						width: 1
					},
					crossStyle: {
						color: "#008acd",
						width: 1
					},
					shadowStyle: {
						color: "rgba(200,200,200,0.2)"
					}
				}
			},
			grid: {
				x: 40,
				y: 20,
				x2: 30,
				y2: 50
			},
			categoryAxis: {
				axisLine: {
					show: !1
				},
				axisTick: {
					show: !1
				},
				splitLine: {
					lineStyle: {
						color: "#f3f3f3"
					}
				}
			},
			valueAxis: {
				axisLine: {
					show: !1
				},
				axisTick: {
					show: !1
				},
				splitLine: {
					lineStyle: {
						color: "#f3f3f3"
					}
				},
				splitArea: {
					show: !1
				}
			},
			line: {
				itemStyle: {
					normal: {
						lineStyle: {
							width: 2,
							type: "solid"
						}
					}
				},
				smooth: !0,
				symbolSize: 6
			},
			textStyle: {
				fontFamily: "Hiragino Sans GB, Microsoft YaHei, STHeiti, Helvetica Neue, Helvetica, Arial, sans-serif"
			},
			animationDuration: 500
		}
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").directive("ngPlaceholder", function () {
		return {
			restrict: "A",
			scope: {
				placeholder: "=ngPlaceholder"
			},
			link: function (e, t) {
				e.$watch("placeholder", function () {
					t[0].placeholder = e.placeholder
				})
			}
		}
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").directive("ngSetting", ["$timeout", "$translate", "ariaNgConstants", function (e, t, a) {
				return {
					restrict: "E",
					templateUrl: "views/setting.html",
					require: "?ngModel",
					replace: !0,
					scope: {
						option: "=",
						ngModel: "=",
						defaultValue: "=?",
						onChangeValue: "&"
					},
					link: function (n, i, s, o) {
						var r = null,
						l = {
							lazySaveTimeout: a.lazySaveTimeout,
							errorTooltipDelay: a.errorTooltipDelay
						};
						angular.extend(l, s);
						var c = function () {
							angular.element(i).tooltip("destroy")
						},
						d = function (a, s, o) {
							a && e(function () {
								var e = n.optionStatus.getValue();
								"failed" !== e && "error" !== e || angular.element(i).tooltip({
									title: t.instant(a, o),
									trigger: "focus",
									placement: "auto top",
									container: i,
									template: '<div class="tooltip' + (s ? " tooltip-" + s : "") + '" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
								}).tooltip("show")
							}, l.errorTooltipDelay)
						},
						u = function (e) {
							if (!e || parseInt(e).toString() != e)
								return e;
							for (var t = ["", "K", "M", "G"], a = 0, n = 0; n < t.length && !(e < 1024 || e % 1024 != 0); n++)
								e /= 1024, a++;
							return e + t[a]
						},
						p = function (e) {
							return "Bytes" === n.option.suffix ? u(e) : e
						};
						n.optionStatus = function () {
							var e = "ready";
							return {
								getValue: function () {
									return e
								},
								setReady: function () {
									c(),
									e = "ready"
								},
								setPending: function () {
									c(),
									e = "pending"
								},
								setSaving: function () {
									c(),
									e = "pending"
								},
								setSuccess: function () {
									c(),
									e = "success"
								},
								setFailed: function (t) {
									c(),
									e = "failed",
									d(t, "warning")
								},
								setError: function (t, a) {
									c(),
									e = "error",
									d(t, "error", a)
								},
								getStatusFeedbackStyle: function () {
									return "success" === e ? "has-success" : "failed" === e ? "has-warning" : "error" === e ? "has-error" : ""
								},
								getStatusIcon: function () {
									return "pending" === e ? "fa-hourglass-start" : "saving" === e ? "fa-spin fa-pulse fa-spinner" : "success" === e ? "fa-check" : "failed" === e ? "fa-exclamation" : "error" === e ? "fa-times" : ""
								},
								isShowStatusIcon: function () {
									return "" !== this.getStatusIcon()
								}
							}
						}
						(),
						n.getTotalCount = function () {
							return n.optionValue || angular.isString(n.optionValue) ? n.optionValue.split(n.option.split).length : 0
						},
						n.changeValue = function (t, a) {
							if (r && e.cancel(r), n.optionValue = t, n.optionStatus.setReady(), n.option && n.option.key && !n.option.readonly) {
								if (n.option.required && "" === t)
									return void n.optionStatus.setError("Option value cannot be empty!");
								if ("" !== t && "integer" === n.option.type && !/^-?\d+$/.test(t))
									return void n.optionStatus.setError("Input number is invalid!");
								if ("" !== t && "float" === n.option.type && !/^-?(\d*\.)?\d+$/.test(t))
									return void n.optionStatus.setError("Input number is invalid!");
								if ("" !== t && ("integer" === n.option.type || "float" === n.option.type) && (angular.isDefined(n.option.min) || angular.isDefined(n.option.max))) {
									var i = t;
									if ("integer" === n.option.type ? i = parseInt(t) : "float" === n.option.type && (i = parseFloat(t)), angular.isDefined(n.option.min) && i < n.option.min)
										return void n.optionStatus.setError("Input number is below min value!", {
											value: n.option.min
										});
									if (angular.isDefined(n.option.max) && i > n.option.max)
										return void n.optionStatus.setError("Input number is above max value!", {
											value: n.option.max
										})
								}
								if ("" !== t && angular.isDefined(n.option.pattern) && !new RegExp(n.option.pattern).test(t))
									return void n.optionStatus.setError("Input value is invalid!");
								var s = {
									key: n.option.key,
									value: t,
									optionStatus: n.optionStatus
								},
								o = function () {
									n.optionStatus.setSaving(),
									n.onChangeValue(s)
								};
								n.onChangeValue && (a ? (n.optionStatus.setPending(), r = e(function () {
												o()
											}, l.lazySaveTimeout)) : o())
							}
						},
						o && n.$watch(function () {
							return o.$viewValue
						}, function (e) {
							n.optionValue = p(e)
						}),
						n.$watch("option", function () {
							i.find('[data-toggle="popover"]').popover()
						}),
						n.$watch("defaultValue", function (e) {
							var t = e;
							if (n.option && n.option.options)
								for (var a = 0; a < n.option.options.length; a++) {
									var i = n.option.options[a];
									if (i.value === e) {
										t = i.name;
										break
									}
								}
							n.placeholder = p(t)
						})
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").directive("ngSettingDialog", ["ariaNgCommonService", "aria2SettingService", function (e, t) {
				return {
					restrict: "E",
					templateUrl: "views/setting-dialog.html",
					replace: !0,
					scope: {
						setting: "="
					},
					link: function (a, n, i) {
						a.context = {
							isLoading: !1,
							availableOptions: [],
							globalOptions: []
						},
						a.setGlobalOption = function (e, a, n) {
							return t.setGlobalOption(e, a, function (e) {
								e.success && "OK" === e.data ? n.setSuccess() : n.setFailed(e.data.message)
							}, !0)
						};
						var s = function (n) {
							var i = t.getaria2QuickSettingsAvailableOptions(n);
							if (!i)
								return void e.showError("Type is illegal!");
							a.context.availableOptions = t.getSpecifiedOptions(i)
						},
						o = function () {
							return a.context.isLoading = !0,
							t.getGlobalOption(function (e) {
								a.context.isLoading = !1,
								e.success && (a.context.globalOptions = e.data)
							})
						};
						$("#quickSettingModal").on("hidden.bs.modal", function () {
							a.setting = null,
							a.context.availableOptions = [],
							a.context.globalOptions = []
						}),
						a.$watch("setting", function (e) {
							e && (s(e.type), o(), $("#quickSettingModal").modal("show"))
						}, !0)
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").directive("ngTooltip", function () {
		return {
			restrict: "A",
			scope: {
				title: "@ngTooltip"
			},
			link: function (e, t, a) {
				var n = {
					ngTooltipIf: !0,
					ngTooltipPlacement: "top",
					ngTooltipContainer: null,
					ngTooltipTrigger: "hover"
				};
				angular.extend(n, a);
				var i = !0 === n.ngTooltipIf || "true" === n.ngTooltipIf,
				s = function () {
					angular.element(t).tooltip({
						title: e.title,
						placement: n.ngTooltipPlacement,
						container: n.ngTooltipContainer,
						trigger: n.ngTooltipTrigger,
						delay: {
							show: 100,
							hide: 0
						}
					})
				},
				o = function () {
					angular.element(t).attr("title", e.title).tooltip("fixTitle")
				},
				r = function () {
					angular.element(t).tooltip("destroy")
				};
				i && s(),
				e.$watch("title", function () {
					i && o()
				}),
				e.$watch("ngTooltipIf", function (e) {
					angular.isUndefined(e) || (e = !0 === e || "true" === e, i !== e && (e ? s() : r(), i = e))
				})
			}
		}
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").filter("dateDuration", ["moment", function (e) {
				return function (t, a, n) {
					var i = e.duration(t, a);
					return e.utc(i.asMilliseconds()).format(n)
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").filter("fileOrderBy", ["$filter", "ariaNgCommonService", function (e, t) {
				return function (a, n) {
					if (!angular.isArray(a))
						return a;
					var i = t.parseOrderType(n);
					return null === i ? a : "name" === i.type ? e("orderBy")(a, ["fileName"], i.reverse) : "size" === i.type ? e("orderBy")(a, ["length"], i.reverse) : "percent" === i.type ? e("orderBy")(a, ["completePercent"], i.reverse) : a
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").filter("longDate", ["$translate", "moment", function (e, t) {
				return function (a) {
					var n = e.instant("format.longdate");
					return t(a).format(n)
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").filter("peerOrderBy", ["$filter", "ariaNgCommonService", function (e, t) {
				return function (a, n) {
					if (!angular.isArray(a))
						return a;
					var i = t.parseOrderType(n);
					return null === i ? a : "address" === i.type ? e("orderBy")(a, ["ip", "port"], i.reverse) : "client" === i.type ? e("orderBy")(a, ["client.name", "client.version"], i.reverse) : "percent" === i.type ? e("orderBy")(a, ["completePercent"], i.reverse) : "dspeed" === i.type ? e("orderBy")(a, ["downloadSpeed"], i.reverse) : "uspeed" === i.type ? e("orderBy")(a, ["uploadSpeed"], i.reverse) : a
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").filter("percent", ["$filter", function (e) {
				return function (t, a) {
					var n = Math.pow(10, a),
					i = parseInt(t * n) / n;
					return e("number")(i, a)
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").filter("taskOrderBy", ["$filter", "ariaNgCommonService", function (e, t) {
				return function (a, n) {
					if (!angular.isArray(a))
						return a;
					var i = t.parseOrderType(n);
					return null === i ? a : "name" === i.type ? e("orderBy")(a, ["taskName"], i.reverse) : "size" === i.type ? e("orderBy")(a, ["totalLength"], i.reverse) : "percent" === i.type ? e("orderBy")(a, ["completePercent"], i.reverse) : "remain" === i.type ? e("orderBy")(a, ["idle", "remainTime", "remainLength"], i.reverse) : "dspeed" === i.type ? e("orderBy")(a, ["downloadSpeed"], i.reverse) : "uspeed" === i.type ? e("orderBy")(a, ["uploadSpeed"], i.reverse) : a
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").filter("taskStatus", function () {
		return function (e) {
			return e ? "active" === e.status ? !0 === e.seeder || "true" === e.seeder ? "Seeding" : "Downloading" : "waiting" === e.status ? "Waiting" : "paused" === e.status ? "Paused" : "complete" === e.status ? "Completed" : "error" === e.status ? e.errorCode ? "format.task.error-occurred" : "Error Occurred" : "removed" === e.status ? "Removed" : "" : ""
		}
	})
}
(), function () {
	"use strict";
	angular.module("ariaNg").filter("readableVolume", ["$filter", function (e) {
				var t = ["B", "KB", "MB", "GB"];
				return function (a, n) {
					var i = t[0];
					angular.isUndefined(n) && (n = 2),
					a || (a = 0),
					angular.isNumber(a) || (a = parseInt(a));
					for (var s = 1; s < t.length && a >= 1024; s++)
						a /= 1024, i = t[s];
					return (a = e("number")(a, n)) + " " + i
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("ariaNgCommonService", ["$location", "$timeout", "base64", "SweetAlert", "$translate", "ariaNgConstants", function (e, t, a, n, i, s) {
				return {
					generateUniqueId: function () {
						var e = s.appPrefix + "_" + Math.round((new Date).getTime() / 1e3) + "_" + Math.random();
						return a.encode(e)
					},
					showDialog: function (e, a, s) {
						t(function () {
							n.swal({
								title: i.instant(e),
								text: i.instant(a),
								type: s,
								confirmButtonText: i.instant("OK")
							})
						}, 100)
					},
					showError: function (e) {
						this.showDialog("Error", e, "error")
					},
					showOperationSucceeded: function (e) {
						this.showDialog("Operation Succeeded", e, "success")
					},
					confirm: function (e, t, a, s, o, r) {
						var l = {
							title: i.instant(e),
							text: i.instant(t, angular.isObject(r) ? r.textParams : null),
							type: a,
							showCancelButton: !0,
							showLoaderOnConfirm: !!o,
							closeOnConfirm: !o,
							confirmButtonText: i.instant("OK"),
							cancelButtonText: i.instant("Cancel")
						};
						"warning" === a && (l.confirmButtonColor = "#F39C12"),
						n.swal(l, function (e) {
							e && s && s()
						})
					},
					getFileExtension: function (e) {
						return !e || e.lastIndexOf(".") < 0 ? e : e.substring(e.lastIndexOf("."))
					},
					decodePercentEncodedString: function (e) {
						if (!e)
							return e;
						for (var t = "", a = 0; a < e.length; a++) {
							var n = e.charAt(a);
							if ("%" === n && a < e.length - 2) {
								var i = e.substring(a + 1, a + 3);
								t += String.fromCharCode(parseInt(i, 16)),
								a += 2
							} else
								t += n
						}
						return t
					},
					extendArray: function (e, t, a) {
						if (!t || !e || e.length !== t.length)
							return !1;
						for (var n = 0; n < t.length; n++) {
							if (t[n][a] !== e[n][a])
								return !1;
							angular.extend(t[n], e[n])
						}
						return !0
					},
					copyObjectTo: function (e, t) {
						if (!t)
							return e;
						for (var a in e)
							if (e.hasOwnProperty(a)) {
								var n = e[a],
								i = t[a];
								angular.isObject(n) || angular.isArray(n) ? t[a] = this.copyObjectTo(e[a], t[a]) : n !== i && (t[a] = n)
							}
						return t
					},
					pushArrayTo: function (e, t) {
						if (angular.isArray(e) || (e = []), !angular.isArray(t) || t.length < 1)
							return e;
						for (var a = 0; a < t.length; a++)
							e.push(t[a]);
						return e
					},
					combineArray: function () {
						for (var e = [], t = 0; t < arguments.length; t++)
							angular.isArray(arguments[t]) ? this.pushArrayTo(e, arguments[t]) : e.push(arguments[t]);
						return e
					},
					countArray: function (e, t) {
						if (!angular.isArray(e) || e.length < 1)
							return 0;
						for (var a = 0, n = 0; n < e.length; n++)
							a += e[n] === t ? 1 : 0;
						return a
					},
					parseOrderType: function (e) {
						var t = e.split(":"),
						a = {
							type: t[0],
							order: t[1],
							equals: function (e) {
								return angular.isUndefined(e.order) ? this.type === e.type : this.type === e.type && this.order === e.order
							},
							getValue: function () {
								return this.type + ":" + this.order
							}
						};
						return Object.defineProperty(a, "reverse", {
							get: function () {
								return "desc" === this.order
							},
							set: function (e) {
								this.order = e ? "desc" : "asc"
							}
						}),
						a
					},
					getTimeOptions: function (e, t) {
						var a = [];
						if (t && a.push({
								name: "Disabled",
								value: 0,
								optionValue: 0
							}), !angular.isArray(e) || e.length < 1)
							return a;
						for (var n = 0; n < e.length; n++) {
							var i = e[n],
							s = "",
							o = i;
							i < 1e3 ? (o = i, s = 1 === o ? "format.time.millisecond" : "format.time.milliseconds") : i < 6e4 ? (o = i / 1e3, s = 1 === o ? "format.time.second" : "format.time.seconds") : i < 144e4 ? (o = i / 1e3 / 60, s = 1 === o ? "format.time.minute" : "format.time.minutes") : (o = i / 1e3 / 60 / 24, s = 1 === o ? "format.time.hour" : "format.time.hours"),
							a.push({
								name: s,
								value: o,
								optionValue: i
							})
						}
						return a
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("ariaNgFileService", ["$window", function (e) {
				var t = !!e.FileReader,
				a = function (e) {
					var t = [];
					if (!e || e.length < 1)
						return t.push(/.+$/), t;
					for (var a = e.split(","), n = 0; n < a.length; n++) {
						var i = a[n];
						"*.*" !== i ? (i = i.replace(".", "\\."), i += "$", t.push(new RegExp(i))) : t.push(/.+$/)
					}
					return t
				},
				n = function (e, t) {
					if (!t || t.length < 1)
						return !0;
					for (var a = 0; a < t.length; a++)
						if (t[a].test(e))
							return !0;
					return !1
				};
				return {
					openFileContent: function (e, i, s) {
						if (!t)
							return void(s && s("Your browser does not support loading file!"));
						var o = a(e);
						angular.element('<input type="file" style="display: none"/>').change(function () {
							if (this.files && !(this.files.length < 1)) {
								var e = this.files[0],
								t = e.name;
								if (!n(t, o))
									return void(s && s("The selected file type is invalid!"));
								var a = new FileReader;
								a.onload = function () {
									var e = {
										fileName: t,
										base64Content: this.result.replace(/.*?base64,/, "")
									};
									i && i(e)
								},
								a.onerror = function () {
									s && s("Failed to load file!")
								},
								a.readAsDataURL(e)
							}
						}).trigger("click")
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("ariaNgLanguageLoader", ["$http", "$q", "localStorageService", "ariaNgConstants", "ariaNgLanguages", function (e, t, a, n, i) {
				var s = function (e) {
					for (var t = 0; t < e.length; t++)
						if (t > 0 && "\\" !== e.charAt(t - 1) && "=" === e.charAt(t))
							return {
								key: e.substring(0, t).replace("\\=", "="),
								value: e.substring(t + 1, e.length).replace("\\=", "=")
							};
					return {
						value: e
					}
				},
				o = function (e, t) {
					var a = e;
					if (!t)
						return a;
					if ("[" === t[0] && "]" === t[t.length - 1] && (t = t.substring(1, t.length - 1)), "default" === t)
						return a;
					for (var n = t.split("."), i = 0; i < n.length; i++) {
						var s = n[i];
						a[s] || (a[s] = {}),
						a = a[s]
					}
					return a
				},
				r = function (e) {
					var t = {};
					if (!e)
						return t;
					for (var a = e.split("\n"), n = t, i = 0; i < a.length; i++) {
						var r = a[i];
						if (r)
							if (r = r.replace("\r", ""), /^\[.+\]$/.test(r))
								n = o(t, r);
							else {
								var l = s(r);
								l && l.key && (n[l.key] = l.value)
							}
					}
					return t
				};
				return function (s) {
					var o = t.defer();
					if (!i[s.key])
						return o.reject(s.key), o.promise;
					var l = n.languageStorageKeyPrefix + "." + s.key,
					c = a.get(l);
					c && o.resolve(c);
					var d = n.languagePath + "/" + s.key + n.languageFileExtension;
					return e({
						url: d,
						method: "GET"
					}).then(function (e) {
						var t = r(e.data);
						return a.set(l, t),
						o.resolve(t)
					}).catch(function (e) {
						return o.reject(s.key)
					}),
					o.promise
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("ariaNgMonitorService", ["$filter", "$translate", "moment", "ariaNgConstants", function (e, t, a, n) {
				var i = {},
				s = {},
				o = function (e) {
					return "global" === e ? n.globalStatStorageCapacity : n.taskStatStorageCapacity
				},
				r = function (n) {
					for (var i = {
							legend: {
								show: !1
							},
							grid: {
								x: 50,
								y: 10,
								x2: 10,
								y2: 10
							},
							tooltip: {
								show: !0,
								formatter: function (n) {
									if ("" === n[0].name)
										return "<div>" + t.instant("No Data")
											 + "</div>";
										var i = a(n[0].name, "X").format("HH:mm:ss"),
										s = e("readableVolume")(n[0].value) + "/s";
										return "<div>" + i + '</div><div><i class="icon-download fa fa-arrow-down"></i> ' + e("readableVolume")(n[1].value) + '/s</div><div><i class="icon-upload fa fa-arrow-up"></i> ' + s + "</div>"
									}
								},
								xAxis: {
									data: [],
									type: "category",
									boundaryGap: !1,
									axisLabel: {
										show: !1
									}
								},
								yAxis: {
									type: "value",
									axisLabel: {
										formatter: function (t) {
											return e("readableVolume")(t, 0)
										}
									}
								},
								series: [{
										type: "line",
										areaStyle: {
											normal: {
												opacity: .1
											}
										},
										smooth: !0,
										symbolSize: 6,
										showAllSymbol: !1,
										data: []
									}, {
										type: "line",
										areaStyle: {
											normal: {
												opacity: .1
											}
										},
										smooth: !0,
										symbolSize: 6,
										showAllSymbol: !1,
										data: []
									}
								]
							}, r = i.xAxis.data, l = i.series[0].data, c = i.series[1].data, d = 0; d < o(n); d++)r.push(""), l.push(""), c.push("");
					return s[n] = i,
					i
				},
				l = function (e) {
					return angular.isDefined(s[e])
				},
				c = function (e, t) {
					var a = s[e],
					n = a.xAxis.data,
					i = a.series[0].data,
					r = a.series[1].data;
					n.length >= o(e) && (n.shift(), i.shift(), r.shift()),
					n.push(t.time),
					i.push(t.uploadSpeed),
					r.push(t.downloadSpeed)
				},
				d = function (e) {
					return s[e]
				},
				u = function (e) {
					delete s[e]
				};
				return {
					recordStat: function (e, t) {
						l(e) || r(e),
						t.time = a().format("X"),
						c(e, t)
					},
					getStatsData: function (e) {
						return l(e) || r(e),
						d(e)
					},
					getEmptyStatsData: function (e) {
						return l(e) && u(e),
						this.getStatsData(e)
					},
					recordGlobalStat: function (e) {
						this.recordStat("global", e),
						i = e
					},
					getGlobalStatsData: function () {
						return this.getStatsData("global")
					},
					getCurrentGlobalStat: function () {
						return i
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("ariaNgNotificationService", ["$notification", "$translate", "Notification", "ariaNgSettingService", function (e, t, a, n) {
				var i = e.isSupported,
				s = function (e) {
					return "granted" === e
				};
				return {
					isSupportBrowserNotification: function () {
						return i
					},
					isPermissionGranted: function (e) {
						return s(e)
					},
					hasBrowserPermission: function () {
						return !!i && s(e.getPermission())
					},
					requestBrowserPermission: function (t) {
						i && e.requestPermission().then(function (e) {
							s(e) || n.setBrowserNotification(!1),
							t && t(e)
						})
					},
					notifyViaBrowser: function (a, s) {
						i && n.getBrowserNotification() && e(t.instant(a), {
							body: t.instant(s)
						})
					},
					notifyInPage: function (e, n, i) {
						return i || (i = {}),
						e && (e = t.instant(e)),
						n && (n = t.instant(n)),
						n ? (i.title = e, i.message = n) : i.message = e,
						i.type && a[i.type] || (i.type = "primary"),
						a[i.type](i)
					},
					notifyTaskComplete: function (e) {
						this.notifyViaBrowser("Download Completed", e && e.taskName ? e.taskName : "")
					},
					notifyBtTaskComplete: function (e) {
						this.notifyViaBrowser("BT Download Completed", e && e.taskName ? e.taskName : "")
					},
					notifyTaskError: function (e) {
						this.notifyViaBrowser("Download Error", e && e.taskName ? e.taskName : "")
					},
					clearNotificationInPage: function () {
						a.clearAll()
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("ariaNgSettingService", ["$window", "$location", "$filter", "$translate", "base64", "amMoment", "localStorageService", "ariaNgConstants", "ariaNgDefaultOptions", "ariaNgLanguages", "ariaNgCommonService", function (e, t, a, n, i, s, o, r, l, c, d) {
				var u = [],
				p = {
					debugMode: !1
				},
				f = function () {
					if (angular.isArray(u) && !(u.length < 1))
						for (var e = 0; e < u.length; e++) {
							var t = u[e];
							t()
						}
				},
				g = function () {
					var t = e.navigator.browserLanguage ? e.navigator.browserLanguage : e.navigator.language;
					return t ? (t = t.replace(/\-/g, "_"), c[t] ? t : l.language) : l.language
				},
				m = function () {
					var e = t.host();
					return e || r.defaultHost
				},
				h = function (e) {
					return o.set(r.optionStorageKey, e)
				},
				v = function () {
					var e = o.get(r.optionStorageKey);
					return e || (e = angular.extend({}, l), e.language = g(), h(e), f()),
					e
				},
				b = function (e) {
					var t = v();
					return angular.isUndefined(t[e]) && angular.isDefined(l[e]) && (t[e] = l[e], h(t)),
					t[e]
				},
				y = function (e, t) {
					var a = v();
					a[e] = t,
					h(a)
				},
				k = function (e) {
					return {
						rpcAlias: e.rpcAlias,
						rpcHost: e.rpcHost,
						rpcPort: e.rpcPort,
						rpcInterface: e.rpcInterface,
						protocol: e.protocol,
						httpMethod: e.httpMethod,
						secret: e.secret
					}
				},
				w = function () {
					var e = k(l);
					return e.rpcId = d.generateUniqueId(),
					e.rpcHost = m(),
					e
				};
				return {
					getAllOptions: function () {
						var e = angular.extend({}, l, v());
						if (e.rpcHost || (e.rpcHost = m()), e.secret && (e.secret = i.decode(e.secret)), angular.isArray(e.extendRpcServers))
							for (var t = 0; t < e.extendRpcServers.length; t++) {
								var a = e.extendRpcServers[t];
								a.rpcHost || (a.rpcHost = m()),
								a.secret && (a.secret = i.decode(a.secret))
							}
						return e
					},
					getAllRpcSettings: function () {
						var e = [],
						t = this.getAllOptions(),
						a = k(t);
						if (a.isDefault = !0, e.push(a), angular.isArray(t.extendRpcServers))
							for (var n = 0; n < t.extendRpcServers.length; n++) {
								var i = k(t.extendRpcServers[n]);
								i.rpcId = t.extendRpcServers[n].rpcId,
								i.isDefault = !1,
								e.push(i)
							}
						return e
					},
					getAllSessionOptions: function () {
						return angular.copy(p)
					},
					applyLanguage: function (e) {
						return !!c[e] && (n.use(e), s.changeLocale(e), !0)
					},
					getLanguage: function () {
						return b("language")
					},
					setLanguage: function (e) {
						this.applyLanguage(e) && y("language", e)
					},
					isEnableDebugMode: function () {
						return p.debugMode
					},
					setDebugMode: function (e) {
						p.debugMode = e
					},
					getTitle: function () {
						return b("title")
					},
					setTitle: function (e) {
						y("title", e)
					},
					getTitleRefreshInterval: function () {
						return b("titleRefreshInterval")
					},
					setTitleRefreshInterval: function (e) {
						y("titleRefreshInterval", Math.max(parseInt(e), 0))
					},
					getAfterCreatingNewTask: function () {
						return b("afterCreatingNewTask")
					},
					setAfterCreatingNewTask: function (e) {
						y("afterCreatingNewTask", e)
					},
					getBrowserNotification: function () {
						return b("browserNotification")
					},
					setBrowserNotification: function (e) {
						y("browserNotification", e)
					},
					getCurrentRpcUrl: function () {
						var e = b("protocol"),
						t = b("rpcHost"),
						a = b("rpcPort"),
						n = b("rpcInterface");
						return t || (t = m()),
						e + "://" + t + ":" + a + "/" + n
					},
					getCurrentRpcProtocol: function () {
						return b("protocol")
					},
					getCurrentRpcHttpMethod: function () {
						return b("httpMethod")
					},
					isCurrentRpcUseWebSocket: function (e) {
						return e || (e = this.getCurrentRpcProtocol()),
						"ws" === e || "wss" === e
					},
					getCurrentRpcSecret: function () {
						var e = b("secret");
						return e ? i.decode(e) : e
					},
					addNewRpcSetting: function () {
						var e = v();
						angular.isArray(e.extendRpcServers) || (e.extendRpcServers = []);
						var t = w();
						return e.extendRpcServers.push(t),
						h(e),
						t
					},
					updateRpcSetting: function (e, t) {
						if (!e)
							return e;
						var a = k(e);
						if (angular.isUndefined(a[t]))
							return e;
						var n = a[t];
						if ("rpcPort" === t ? n = Math.max(parseInt(n), 0) : "secret" === t && n && (n = i.encode(n)), e.isDefault)
							return y(t, n), e;
						var s = v();
						if (!angular.isArray(s.extendRpcServers))
							return e;
						for (var o = 0; o < s.extendRpcServers.length; o++)
							if (s.extendRpcServers[o].rpcId === e.rpcId) {
								s.extendRpcServers[o][t] = n;
								break
							}
						return h(s),
						e
					},
					removeRpcSetting: function (e) {
						var t = v();
						if (!angular.isArray(t.extendRpcServers))
							return e;
						for (var a = 0; a < t.extendRpcServers.length; a++)
							if (t.extendRpcServers[a].rpcId === e.rpcId) {
								t.extendRpcServers.splice(a, 1);
								break
							}
						return h(t),
						e
					},
					setDefaultRpcSetting: function (e, t) {
						t = angular.extend({
								keepCurrent: !0,
								forceSet: !1
							}, t);
						var a = v(),
						n = k(a);
						n.rpcId = d.generateUniqueId(),
						angular.isArray(a.extendRpcServers) || (a.extendRpcServers = []);
						for (var s = null, o = 0; o < a.extendRpcServers.length; o++)
							if (a.extendRpcServers[o].rpcId === e.rpcId) {
								s = k(a.extendRpcServers[o]),
								a.extendRpcServers.splice(o, 1);
								break
							}
						return t.forceSet && (s = k(e), s.secret && (s.secret = i.encode(s.secret))),
						s && (t.keepCurrent && a.extendRpcServers.splice(0, 0, n), a = angular.extend(a, s)),
						h(a),
						e
					},
					isRpcSettingEqualsDefault: function (e) {
						if (!e)
							return !1;
						var t = this.getAllOptions();
						return t.rpcHost === e.rpcHost && (t.rpcPort === e.rpcPort && (t.rpcInterface === e.rpcInterface && (t.protocol === e.protocol && (t.httpMethod === e.httpMethod && t.secret === e.secret))))
					},
					getGlobalStatRefreshInterval: function () {
						return b("globalStatRefreshInterval")
					},
					setGlobalStatRefreshInterval: function (e) {
						y("globalStatRefreshInterval", Math.max(parseInt(e), 0))
					},
					getDownloadTaskRefreshInterval: function () {
						return b("downloadTaskRefreshInterval")
					},
					setDownloadTaskRefreshInterval: function (e) {
						y("downloadTaskRefreshInterval", Math.max(parseInt(e), 0))
					},
					getDisplayOrder: function () {
						var e = b("displayOrder");
						return e || (e = "default:asc"),
						e
					},
					setDisplayOrder: function (e) {
						y("displayOrder", e)
					},
					getFileListDisplayOrder: function () {
						var e = b("fileListDisplayOrder");
						return e || (e = "default:asc"),
						e
					},
					setFileListDisplayOrder: function (e) {
						y("fileListDisplayOrder", e)
					},
					getPeerListDisplayOrder: function () {
						var e = b("peerListDisplayOrder");
						return e || (e = "default:asc"),
						e
					},
					setPeerListDisplayOrder: function (e) {
						y("peerListDisplayOrder", e)
					},
					onFirstAccess: function (e) {
						e && u.push(e)
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("ariaNgTitleService", ["$filter", "$translate", "ariaNgConstants", "ariaNgSettingService", function (e, t, a, n) {
				var i = function (e) {
					if (!e)
						return {};
					for (var t = e.substring(2, e.length - 1), a = t.split(":"), n = {
							oldValue: e
						}, i = 1; i < a.length; i++) {
						var s = a[i].split("=");
						1 === s.length ? n[s[0]] = !0 : 2 === s.length && (n[s[0]] = s[1])
					}
					return n
				},
				s = function (t, a) {
					var n = a.value;
					return "volume" === a.type && (n = e("readableVolume")(n, a.scale)),
					a.prefix && !a.noprefix && (n = a.prefix + n),
					a.suffix && !a.nosuffix && (n += a.suffix),
					t.replace(a.oldValue, n)
				},
				o = function (e, t, a) {
					var n = new RegExp("\\$\\{" + t + "(:[a-zA-Z0-9]+(=[a-zA-Z0-9]+)?)*\\}", "g"),
					o = e.match(n);
					if (o && o.length > 0)
						for (var r = 0; r < o.length; r++) {
							var l = i(o[r]);
							angular.extend(l, a),
							e = s(e, l)
						}
					return e
				},
				r = function (e, a) {
					return o(e, "downloading", {
						prefix: t.instant("Downloading") + ": ",
						value: a
					})
				},
				l = function (e, a) {
					return o(e, "waiting", {
						prefix: t.instant("Waiting") + ": ",
						value: a
					})
				},
				c = function (e, a) {
					return o(e, "stopped", {
						prefix: t.instant("Finished / Stopped"),
						value: a
					})
				},
				d = function (e, a) {
					return o(e, "downspeed", {
						prefix: t.instant("Download") + ": ",
						value: a,
						type: "volume",
						suffix: "/s"
					})
				},
				u = function (e, a) {
					return o(e, "upspeed", {
						prefix: t.instant("Upload") + ": ",
						value: a,
						type: "volume",
						suffix: "/s"
					})
				},
				p = function (e) {
					return o(e, "title", {
						value: a.title
					})
				};
				return {
					getFinalTitle: function (e) {
						var t = n.getTitle();
						return e = angular.extend({
								downloadingCount: 0,
								waitingCount: 0,
								stoppedCount: 0,
								downloadSpeed: 0,
								uploadSpeed: 0
							}, e),
						t = r(t, e.downloadingCount),
						t = l(t, e.waitingCount),
						t = c(t, e.stoppedCount),
						t = d(t, e.downloadSpeed),
						t = u(t, e.uploadSpeed),
						t = p(t)
					},
					getFinalTitleByGlobalStat: function (e) {
						var t = {
							downloadingCount: e ? e.numActive : 0,
							waitingCount: e ? e.numWaiting : 0,
							stoppedCount: e ? e.numStopped : 0,
							downloadSpeed: e ? e.downloadSpeed : 0,
							uploadSpeed: e ? e.uploadSpeed : 0
						};
						return this.getFinalTitle(t)
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("ariaNgLogService", ["$log", "ariaNgSettingService", function (e, t) {
				return {
					debug: function (a, n) {
						t.isEnableDebugMode() && (n ? e.debug("[AriaNg Debug]" + a, n) : e.debug("[AriaNg Debug]" + a))
					},
					info: function (t, a) {
						a ? e.info("[AriaNg Info]" + t, a) : e.info("[AriaNg Info]" + t)
					},
					warn: function (t, a) {
						a ? e.warn("[AriaNg Warn]" + t, a) : e.warn("[AriaNg Warn]" + t)
					},
					error: function (t, a) {
						a ? e.error("[AriaNg Error]" + t, a) : e.error("[AriaNg Error]" + t)
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("aria2HttpRpcService", ["$http", "base64", "ariaNgSettingService", "ariaNgLogService", function (e, t, a, n) {
				var i = a.getCurrentRpcUrl(),
				s = a.getCurrentRpcHttpMethod(),
				o = function (e, a) {
					if (!e || e.length < 1)
						return e;
					var n = "";
					for (var i in a)
						if (a.hasOwnProperty(i)) {
							var s = a[i];
							null === s || angular.isUndefined(s) || (n.length > 0 && (n += "&"), (angular.isObject(s) || angular.isArray(s)) && (s = angular.toJson(s), s = t.encode(s), s = encodeURIComponent(s)), n += i + "=" + s)
						}
					return n.length < 1 ? e : (n = e.indexOf("?") < 0 ? "?" + n : "&" + n, e + n)
				};
				return {
					request: function (t) {
						if (t) {
							var a = {
								url: i,
								method: s
							};
							return "POST" === a.method ? a.data = t.requestBody : "GET" === a.method && (a.url = o(a.url, t.requestBody)),
							n.debug("[aria2HttpRpcService.request] request start", a),
							e(a).then(function (e) {
								var a = e.data;
								n.debug("[aria2HttpRpcService.request] response success", a),
								a && t.successCallback && t.successCallback(a.id, a.result)
							}).catch(function (e) {
								var a = e.data;
								n.debug("[aria2HttpRpcService.request] response error", a),
								a || (a = {
										id: "-1",
										error: {
											innerError: !0
										}
									}),
								t.errorCallback && t.errorCallback(a.id, a.error)
							})
						}
					},
					on: function (e, t) {}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("aria2WebSocketRpcService", ["$q", "$websocket", "ariaNgSettingService", "ariaNgLogService", function (e, t, a, n) {
				var i = a.getCurrentRpcUrl(),
				s = null,
				o = {},
				r = {},
				l = function (e) {
					var t = e.id;
					if (t) {
						var a = o[t];
						if (a) {
							var i = a.context;
							a.deferred.resolve({
								success: !0,
								context: i
							}),
							e.result && i.successCallback && (n.debug("[aria2WebSocketRpcService.request] response uccess", e), i.successCallback(i.id, e.result)),
							e.error && i.errorCallback && (n.debug("[aria2WebSocketRpcService.request] response error", e), i.errorCallback(i.id, e.error)),
							delete o[t]
						}
					}
				},
				c = function (e) {
					var t = e.method;
					if (t) {
						var a = r[t];
						if (angular.isArray(a) && !(a.length < 1))
							for (var n = 0; n < a.length; n++) {
								var i = a[n],
								s = angular.isArray(e.params) && e.params.length > 0 ? e.params[0] : null;
								i(s)
							}
					}
				},
				d = function () {
					return null === s && (s = t(i), s.onMessage(function (e) {
							if (e && e.data) {
								var t = angular.fromJson(e.data);
								t && (t.id ? l(t) : t.method && c(t))
							}
						})),
					s
				};
				return {
					request: function (t) {
						if (t) {
							var a = d(),
							i = t.uniqueId,
							s = angular.toJson(t.requestBody);
							n.debug("[aria2WebSocketRpcService.request] request start", t);
							var r = e.defer();
							return o[i] = {
								context: t,
								deferred: r
							},
							a.send(s),
							r.promise
						}
					},
					on: function (e, t) {
						var a = r[e];
						angular.isArray(a) || (a = r[e] = []),
						a.push(t)
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("aria2RpcService", ["$q", "aria2RpcConstants", "aria2RpcErrors", "ariaNgCommonService", "ariaNgSettingService", "ariaNgLogService", "aria2HttpRpcService", "aria2WebSocketRpcService", function (e, t, a, n, i, s, o, r) {
				var l = i.isCurrentRpcUseWebSocket() ? r : o,
				c = !1,
				d = i.getCurrentRpcSecret(),
				u = [],
				p = [],
				f = [],
				g = [],
				m = [],
				h = [],
				v = [],
				b = [],
				y = [],
				k = function (e) {
					return 0 === e.indexOf(t.rpcSystemServiceName + ".")
				},
				w = function (e) {
					return t.rpcServiceName + "." + e
				},
				S = function (e) {
					return w(e)
				},
				x = function (e, a) {
					if (a)
						return e;
					var i = n.generateUniqueId(),
					s = {
						jsonrpc: t.rpcServiceVersion,
						method: e.methodName,
						id: i,
						params: e.params
					},
					o = {
						uniqueId: i,
						requestBody: s,
						successCallback: e.successCallback,
						errorCallback: e.errorCallback
					};
					return l.request(o)
				},
				T = function (e, t) {
					var a = S(e);
					l.on(a, function (e) {
						if (angular.isArray(t) && !(t.length < 1))
							for (var a = 0; a < t.length; a++) {
								var n = t[a];
								n(e)
							}
					})
				},
				C = function (e) {
					if (angular.isArray(e) && !(e.length < 1))
						for (var t = 0; t < e.length; t++) {
							var a = e[t];
							a()
						}
				},
				P = function (t, a, n) {
					for (var i = [], s = !1, o = !1, r = [], l = 0; l < a.length; l++)
						a[l].callback = function (e) {
							r.push(e),
							s |= e.success,
							o |= !e.success
						},
					i.push(t(a[l]));
					return e.all(i).finally(function () {
						n && n({
							hasSuccess: !!s,
							hasError: !!o,
							results: r
						})
					})
				},
				R = function (e) {
					return !(!e || !e.message) && (s.error("[aria2RpcService.processError] " + e.message, e), a[e.message] && a[e.message].tipTextKey ? (n.showError(a[e.message].tipTextKey), !0) : (n.showError(e.message), !0))
				},
				O = function () {
					var e = arguments[0],
					a = k(e),
					n = [],
					i = {
						methodName: a ? e : w(e)
					};
					if (d && !a && n.push(t.rpcTokenPrefix + d), arguments.length > 1) {
						var s = arguments[1];
						i.successCallback = function (e, t) {
							s.callback && s.callback({
								id: e,
								success: !0,
								data: t,
								context: s
							}),
							C(p),
							c || (c = !0, C(u))
						},
						i.errorCallback = function (e, t) {
							var a = !1;
							s.silent || (a = R(t)),
							s.callback && s.callback({
								id: e,
								success: !1,
								data: t,
								errorProcessed: a,
								context: s
							}),
							C(f)
						}
					}
					if (arguments.length > 2)
						for (var o = 2; o < arguments.length; o++)
							null !== arguments[o] && angular.isDefined(arguments[o]) && n.push(arguments[o]);
					return n.length > 0 && (i.params = n),
					i
				};
				return function () {
					T("onDownloadStart", g),
					T("onDownloadPause", m),
					T("onDownloadStop", h),
					T("onDownloadComplete", v),
					T("onDownloadError", b),
					T("onBtDownloadComplete", y)
				}
				(), {
					getBasicTaskParams: function () {
						return ["gid", "totalLength", "completedLength", "uploadSpeed", "downloadSpeed", "connections", "numSeeders", "seeder", "status", "errorCode"]
					},
					getFullTaskParams: function () {
						var e = this.getBasicTaskParams();
						return e.push("files"),
						e.push("bittorrent"),
						e
					},
					addUri: function (e, t) {
						var a = e.task.urls,
						n = angular.copy(e.task.options);
						return e.pauseOnAdded && (n.pause = "true"),
						x(O("addUri", e, a, n), !!t)
					},
					addUriMulti: function (e) {
						for (var t = [], a = 0; a < e.tasks.length; a++) {
							var n = e.tasks[a];
							t.push({
								silent: !!e.silent,
								task: n,
								pauseOnAdded: e.pauseOnAdded
							})
						}
						return P(this.addUri, t, e.callback)
					},
					addTorrent: function (e, t) {
						var a = e.task.content,
						n = angular.copy(e.task.options);
						return e.pauseOnAdded && (n.pause = "true"),
						x(O("addTorrent", e, a, [], n), !!t)
					},
					addMetalink: function (e, t) {
						var a = e.task.content,
						n = angular.copy(e.task.options);
						return e.pauseOnAdded && (n.pause = "true"),
						x(O("addMetalink", e, a, [], n), !!t)
					},
					remove: function (e, t) {
						return x(O("remove", e, e.gid), !!t)
					},
					forceRemove: function (e, t) {
						return x(O("forceRemove", e, e.gid), !!t)
					},
					forceRemoveMulti: function (e) {
						for (var t = [], a = 0; a < e.gids.length; a++)
							t.push({
								silent: !!e.silent,
								gid: e.gids[a]
							});
						return P(this.forceRemove, t, e.callback)
					},
					pause: function (e, t) {
						return x(O("pause", e, e.gid), !!t)
					},
					pauseAll: function (e, t) {
						return x(O("pauseAll", e), !!t)
					},
					forcePause: function (e, t) {
						return x(O("forcePause", e, e.gid), !!t)
					},
					forcePauseMulti: function (e) {
						for (var t = [], a = 0; a < e.gids.length; a++)
							t.push({
								silent: !!e.silent,
								gid: e.gids[a]
							});
						return P(this.forcePause, t, e.callback)
					},
					forcePauseAll: function (e, t) {
						return x(O("forcePauseAll", e), !!t)
					},
					unpause: function (e, t) {
						return x(O("unpause", e, e.gid), !!t)
					},
					unpauseMulti: function (e) {
						for (var t = [], a = 0; a < e.gids.length; a++)
							t.push({
								silent: !!e.silent,
								gid: e.gids[a]
							});
						return P(this.unpause, t, e.callback)
					},
					unpauseAll: function (e, t) {
						return x(O("unpauseAll", e), !!t)
					},
					tellStatus: function (e, t) {
						return x(O("tellStatus", e, e.gid), !!t)
					},
					getUris: function (e, t) {
						return x(O("getUris", e, e.gid), !!t)
					},
					getFiles: function (e, t) {
						return x(O("getFiles", e, e.gid), !!t)
					},
					getPeers: function (e, t) {
						return x(O("getPeers", e, e.gid), !!t)
					},
					getServers: function (e, t) {
						return x(O("getServers", e, e.gid), !!t)
					},
					tellActive: function (e, t) {
						return x(O("tellActive", e, angular.isDefined(e.requestParams) ? e.requestParams : null), !!t)
					},
					tellWaiting: function (e, t) {
						return x(O("tellWaiting", e, angular.isDefined(e.offset) ? e.offset : 0, angular.isDefined(e.num) ? e.num : 1e3, angular.isDefined(e.requestParams) ? e.requestParams : null), !!t)
					},
					tellStopped: function (e, t) {
						return x(O("tellStopped", e, angular.isDefined(e.offset) ? e.offset : -1, angular.isDefined(e.num) ? e.num : 1e3, angular.isDefined(e.requestParams) ? e.requestParams : null), !!t)
					},
					changePosition: function (e, t) {
						return x(O("changePosition", e, e.gid, e.pos, e.how), !!t)
					},
					changeUri: function (e, t) {
						return x(O("changeUri", e, e.gid, e.fileIndex, e.delUris, e.addUris), !!t)
					},
					getOption: function (e, t) {
						return x(O("getOption", e, e.gid), !!t)
					},
					changeOption: function (e, t) {
						return x(O("changeOption", e, e.gid, e.options), !!t)
					},
					getGlobalOption: function (e, t) {
						return x(O("getGlobalOption", e), !!t)
					},
					changeGlobalOption: function (e, t) {
						return x(O("changeGlobalOption", e, e.options), !!t)
					},
					getGlobalStat: function (e, t) {
						return x(O("getGlobalStat", e), !!t)
					},
					purgeDownloadResult: function (e, t) {
						return x(O("purgeDownloadResult", e), !!t)
					},
					removeDownloadResult: function (e, t) {
						return x(O("removeDownloadResult", e, e.gid), !!t)
					},
					removeDownloadResultMulti: function (e) {
						for (var t = [], a = 0; a < e.gids.length; a++)
							t.push({
								silent: !!e.silent,
								gid: e.gids[a]
							});
						return P(this.removeDownloadResult, t, e.callback)
					},
					getVersion: function (e, t) {
						return x(O("getVersion", e), !!t)
					},
					getSessionInfo: function (e, t) {
						return x(O("getSessionInfo", e), !!t)
					},
					shutdown: function (e, t) {
						return x(O("shutdown", e), !!t)
					},
					forceShutdown: function (e, t) {
						return x(O("forceShutdown", e), !!t)
					},
					saveSession: function (e, t) {
						return x(O("saveSession", e), !!t)
					},
					multicall: function (e) {
						return x(O("system.multicall", e, e.methods))
					},
					listMethods: function (e) {
						return x(O("system.listMethods", e))
					},
					onFirstSuccess: function (e) {
						u.push(e.callback)
					},
					onConnectSuccess: function (e) {
						p.push(e.callback)
					},
					onConnectError: function (e) {
						f.push(e.callback)
					},
					onDownloadStart: function (e) {
						g.push(e.callback)
					},
					onDownloadPause: function (e) {
						m.push(e.callback)
					},
					onDownloadStop: function (e) {
						h.push(e.callback)
					},
					onDownloadComplete: function (e) {
						v.push(e.callback)
					},
					onDownloadError: function (e) {
						b.push(e.callback)
					},
					onBtDownloadComplete: function (e) {
						y.push(e.callback)
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("aria2TaskService", ["$q", "$translate", "bittorrentPeeridService", "aria2Errors", "aria2RpcService", "ariaNgCommonService", "ariaNgLogService", function (e, t, a, n, i, s, o) {
				var r = function (e) {
					if (!e)
						return o.warn("[aria2TaskService.getFileName] file is null"), "";
					var t = e.path;
					!t && e.uris && e.uris.length > 0 && (t = e.uris[0].uri);
					var a = t.lastIndexOf("/");
					return a <= 0 || a === t.length ? t : t.substring(a + 1)
				},
				l = function (e, t) {
					return 0 === t ? 0 : e / t
				},
				c = function (e) {
					var a = "",
					n = !0;
					return e.bittorrent && e.bittorrent.info && (a = e.bittorrent.info.name),
					!a && e.files && e.files.length > 0 && (a = r(e.files[0])),
					a || (a = t.instant("Unknown"), n = !1), {
						name: a,
						success: n
					}
				},
				d = function (e) {
					return e.errorCode && n[e.errorCode] && n[e.errorCode].descriptionKey ? n[e.errorCode].hide ? "" : n[e.errorCode].descriptionKey : ""
				},
				u = function (e, t) {
					for (var a = [], n = 0; n < t; n++)
						a.push(!1);
					if (!e)
						return a;
					for (var i = 0, n = 0; n < e.length; n++)
						for (var s = parseInt(e[n], 16), o = 1; o <= 4; o++) {
							var r = 1 << 4 - o,
							l = (s & r) === r;
							if (a[i++] = l, i >= t)
								return a
						}
					return a
				},
				p = function (e, t) {
					for (var a = u(e, t), n = [], i = 0; i < a.length; i++) {
						var s = a[i];
						n.length > 0 && n[n.length - 1].isCompleted === s ? n[n.length - 1].count++ : n.push({
							isCompleted: s,
							count: 1
						})
					}
					return n
				},
				f = function (e) {
					if (!e)
						return o.warn("[aria2TaskService.processDownloadTask] task is null"), e;
					var t = u(e.bitfield, e.numPieces);
					e.totalLength = parseInt(e.totalLength),
					e.completedLength = parseInt(e.completedLength),
					e.completePercent = e.totalLength > 0 ? e.completedLength / e.totalLength * 100 : 0,
					e.remainLength = e.totalLength - e.completedLength,
					e.remainPercent = 100 - e.completePercent,
					e.uploadLength = e.uploadLength ? parseInt(e.uploadLength) : 0,
					e.shareRatio = e.completedLength > 0 ? e.uploadLength / e.completedLength : 0,
					e.uploadSpeed = parseInt(e.uploadSpeed),
					e.downloadSpeed = parseInt(e.downloadSpeed),
					e.numPieces = parseInt(e.numPieces),
					e.completedPieces = s.countArray(t, !0),
					e.pieceLength = parseInt(e.pieceLength),
					e.idle = 0 === e.downloadSpeed,
					e.remainTime = l(e.remainLength, e.downloadSpeed),
					e.seeder = !0 === e.seeder || "true" === e.seeder;
					var a = c(e);
					if (e.taskName = a.name, e.hasTaskName = a.success, e.errorDescription = d(e), e.files) {
						for (var n = 0, i = 0; i < e.files.length; i++) {
							var p = e.files[i];
							p.fileName = r(p),
							p.length = parseInt(p.length),
							p.selected = !0 === p.selected || "true" === p.selected,
							p.completedLength = parseInt(p.completedLength),
							p.completePercent = p.length > 0 ? p.completedLength / p.length * 100 : 0,
							n += p.selected ? 1 : 0
						}
						e.selectedFileCount = n
					}
					return e
				},
				g = function (e, t, n) {
					if (!e)
						return o.warn("[aria2TaskService.processBtPeers] peers is null"), e;
					for (var i = u(t.bitfield, t.numPieces), r = s.countArray(i, !0), l = t.completePercent, c = 0; c < e.length; c++) {
						var d = e[c],
						p = d.uploadSpeed,
						f = d.downloadSpeed,
						g = u(d.bitfield, t.numPieces),
						m = s.countArray(g, !0);
						if (d.name = d.ip + ":" + d.port, d.completePercent = m / t.numPieces * 100, d.downloadSpeed = p, d.uploadSpeed = f, d.seeder = !0 === d.seeder || "true" === d.seeder, m === r && d.completePercent !== l && (d.completePercent = l), d.peerId) {
							var v = s.decodePercentEncodedString(d.peerId),
							b = v ? a.parseClient(v) : null;
							if (b && "unknown" !== b.client) {
								var y = {
									name: b.client ? b.client.trim() : "",
									version: b.version ? b.version.trim() : ""
								};
								y.info = y.name + (y.version ? " " + y.version : ""),
								d.client = y
							}
						}
					}
					return n && e.push(h(t)),
					e
				},
				m = function (e, t, a) {
					return function (n) {
						var i = {
							type: a,
							task: null
						};
						n && n.gid ? e(n.gid, function (e) {
							i.task = e.success ? e.data : null,
							t(i)
						}, !0) : t(i)
					}
				},
				h = function (e) {
					return {
						local: !0,
						bitfield: e.bitfield,
						completePercent: e.completePercent,
						downloadSpeed: e.downloadSpeed,
						name: "(local)",
						seeder: e.seeder,
						uploadSpeed: e.uploadSpeed
					}
				};
				return {
					getTaskList: function (e, t, a, n) {
						var s = null;
						if ("downloading" === e)
							s = i.tellActive;
						else if ("waiting" === e)
							s = i.tellWaiting;
						else {
							if ("stopped" !== e)
								return;
							s = i.tellStopped
						}
						return s({
							requestWholeInfo: t,
							requestParams: t ? i.getFullTaskParams() : i.getBasicTaskParams(),
							silent: !!n,
							callback: function (e) {
								if (!a)
									return void o.warn("[aria2TaskService.getTaskList] callback is null");
								a(e)
							}
						})
					},
					getTaskStatus: function (e, t, a) {
						return i.tellStatus({
							gid: e,
							silent: !!a,
							callback: function (e) {
								if (!t)
									return void o.warn("[aria2TaskService.getTaskStatus] callback is null");
								e.success && f(e.data),
								t(e)
							}
						})
					},
					getTaskOptions: function (e, t, a) {
						return i.getOption({
							gid: e,
							silent: !!a,
							callback: t
						})
					},
					setTaskOption: function (e, t, a, n, s) {
						var o = {};
						return o[t] = a,
						i.changeOption({
							gid: e,
							options: o,
							silent: !!s,
							callback: n
						})
					},
					selectTaskFile: function (e, t, a, n) {
						for (var i = "", s = 0; s < t.length; s++)
							i.length > 0 && (i += ","), i += t[s];
						return this.setTaskOption(e, "select-file", i, a, n)
					},
					getBtTaskPeers: function (e, t, a, n) {
						return i.getPeers({
							gid: e.gid,
							silent: !!a,
							callback: function (a) {
								if (!t)
									return void o.warn("[aria2TaskService.getBtTaskPeers] callback is null");
								a.success && g(a.data, e, n),
								t(a)
							}
						})
					},
					getTaskStatusAndBtPeers: function (e, t, a, n, s) {
						var r = [i.tellStatus({
								gid: e
							}, !0)];
						return n && r.push(i.getPeers({
								gid: e
							}, !0)),
						i.multicall({
							methods: r,
							silent: !!a,
							callback: function (e) {
								if (!t)
									return void o.warn("[aria2TaskService.getTaskStatusAndBtPeers] callback is null");
								e.task = {},
								e.success && e.data.length > 0 && (e.task = e.data[0][0], f(e.task)),
								e.success && e.task.bittorrent && e.data.length > 1 && (e.peers = e.data[1][0], g(e.peers, e.task, s)),
								t(e)
							}
						})
					},
					newUriTask: function (e, t, a, n) {
						return i.addUri({
							task: e,
							pauseOnAdded: !!t,
							silent: !!n,
							callback: a
						})
					},
					newUriTasks: function (e, t, a, n) {
						return i.addUriMulti({
							tasks: e,
							pauseOnAdded: !!t,
							silent: !!n,
							callback: a
						})
					},
					newTorrentTask: function (e, t, a, n) {
						return i.addTorrent({
							task: e,
							pauseOnAdded: !!t,
							silent: !!n,
							callback: a
						})
					},
					newMetalinkTask: function (e, t, a, n) {
						return i.addMetalink({
							task: e,
							pauseOnAdded: !!t,
							silent: !!n,
							callback: a
						})
					},
					startTasks: function (e, t, a) {
						return i.unpauseMulti({
							gids: e,
							silent: !!a,
							callback: t
						})
					},
					pauseTasks: function (e, t, a) {
						return i.forcePauseMulti({
							gids: e,
							silent: !!a,
							callback: t
						})
					},
					restartTask: function (t, a, n) {
						var s = e.defer(),
						r = [i.tellStatus({
								gid: t
							}, !0), i.getOption({
								gid: t
							}, !0)],
						l = null,
						c = null;
						return i.multicall({
							methods: r,
							silent: !!n,
							callback: function (e) {
								if (!a)
									return void o.warn("[aria2TaskService.restartTask] callback is null");
								if (!e.success)
									return o.warn("[aria2TaskService.restartTask] response is not success"), s.reject(e), void a(e);
								if (e.data.length > 0 && (l = e.data[0][0]), e.data.length > 1 && (c = e.data[1][0]), !l || !c || !l.files || 1 != l.files.length || l.bittorrent)
									return l || o.warn("[aria2TaskService.restartTask] task is null"), c || o.warn("[aria2TaskService.restartTask] options is null"), l.files || o.warn("[aria2TaskService.restartTask] task file is null"), 1 != l.files.length && o.warn("[aria2TaskService.restartTask] task file length is not equal 1"), l.bittorrent && o.warn("[aria2TaskService.restartTask] task is bittorrent"), s.reject(t), void a({
										success: !1
									});
								for (var r = l.files[0], d = [], u = 0; u < r.uris.length; u++) {
									var p = r.uris[u];
									d.push(p.uri)
								}
								i.addUri({
									task: {
										urls: d,
										options: c
									},
									pauseOnAdded: !1,
									silent: !!n,
									callback: function (e) {
										if (!e.success)
											return o.warn("[aria2TaskService.restartTask] addUri response is not success"), s.reject(e), void a(e);
										s.resolve(e),
										a(e)
									}
								})
							}
						}),
						s.promise
					},
					removeTasks: function (t, a, n) {
						for (var o = [], r = [], l = 0; l < t.length; l++)
							"complete" === t[l].status || "error" === t[l].status || "removed" === t[l].status ? r.push(t[l].gid) : o.push(t[l].gid);
						var c = [],
						d = !1,
						u = !1,
						p = [];
						return o.length > 0 && c.push(i.forceRemoveMulti({
								gids: o,
								silent: !!n,
								callback: function (e) {
									s.pushArrayTo(p, e.results),
									d |= e.hasSuccess,
									u |= e.hasError
								}
							})),
						r.length > 0 && c.push(i.removeDownloadResultMulti({
								gids: r,
								silent: !!n,
								callback: function (e) {
									s.pushArrayTo(p, e.results),
									d |= e.hasSuccess,
									u |= e.hasError
								}
							})),
						e.all(c).then(function () {
							a && a({
								hasSuccess: !!d,
								hasError: !!u,
								results: p
							})
						})
					},
					changeTaskPosition: function (e, t, a, n) {
						return i.changePosition({
							gid: e,
							pos: t,
							how: "POS_SET",
							silent: !!n,
							callback: a
						})
					},
					clearStoppedTasks: function (e, t) {
						return i.purgeDownloadResult({
							silent: !!t,
							callback: e
						})
					},
					onFirstSuccess: function (e) {
						if (!e)
							return void o.warn("[aria2TaskService.onFirstSuccess] callback is null");
						i.onFirstSuccess({
							callback: e
						})
					},
					onConnectSuccess: function (e) {
						if (!e)
							return void o.warn("[aria2TaskService.onConnectSuccess] callback is null");
						i.onConnectSuccess({
							callback: e
						})
					},
					onConnectError: function (e) {
						if (!e)
							return void o.warn("[aria2TaskService.onConnectError] callback is null");
						i.onConnectError({
							callback: e
						})
					},
					onTaskCompleted: function (e) {
						if (!e)
							return void o.warn("[aria2TaskService.onTaskCompleted] callback is null");
						i.onDownloadComplete({
							callback: m(this.getTaskStatus, e, "completed")
						})
					},
					onBtTaskCompleted: function (e) {
						if (!e)
							return void o.warn("[aria2TaskService.onBtTaskCompleted] callback is null");
						i.onBtDownloadComplete({
							callback: m(this.getTaskStatus, e, "btcompleted")
						})
					},
					onTaskErrorOccur: function (e) {
						if (!e)
							return void o.warn("[aria2TaskService.onTaskErrorOccur] callback is null");
						i.onDownloadError({
							callback: m(this.getTaskStatus, e, "error")
						})
					},
					processDownloadTasks: function (e) {
						if (!angular.isArray(e))
							return void o.warn("[aria2TaskService.processDownloadTasks] tasks is not array");
						for (var t = 0; t < e.length; t++)
							f(e[t])
					},
					getPieceStatus: function (e, t) {
						return u(e, t)
					},
					getCombinedPieces: function (e, t) {
						return p(e, t)
					},
					estimateHealthPercentFromPeers: function (e, t) {
						if (!e || e.numPieces < 1 || t.length < 1)
							return o.warn("[aria2TaskService.estimateHealthPercentFromPeers] tasks is null or numPieces < 1 or peers < 1"), e.completePercent;
						for (var a = [], n = 0, i = e.completePercent, s = 0; s < e.numPieces; s++)
							a.push(0);
						for (var s = 0; s < t.length; s++) {
							for (var r = t[s], l = u(r.bitfield, e.numPieces), c = 0, d = 0; d < l.length; d++) {
								var p = l[d] ? 1 : 0;
								a[d] += p,
								c += p
							}
							c > n ? (n = c, i = r.completePercent) : c === n && r.completePercent > i && (i = r.completePercent)
						}
						var f = 0;
						if (a.length > 0)
							for (; ; ) {
								for (var g = !0, s = 0; s < a.length; s++)
									a[s] > 0 ? (f++, a[s]--) : g = !1;
								if (!g)
									break
							}
						if (f <= n)
							return i;
						var m = f / e.numPieces * 100;
						return m <= i ? i : m
					}
				}
			}
		])
}
(), function () {
	"use strict";
	angular.module("ariaNg").factory("aria2SettingService", ["aria2AllOptions", "aria2GlobalAvailableOptions", "aria2QuickSettingsAvailableOptions", "aria2TaskAvailableOptions", "aria2RpcService", "ariaNgLogService", function (e, t, a, n, i, s) {
				var o = function (e) {
					if (!e)
						return e;
					var t = parseInt(e.numActive),
					a = parseInt(e.numWaiting),
					n = t + a;
					return e.totalRunningCount = n,
					e
				};
				return {
					getAvailableGlobalOptionsKeys: function (e) {
						return "basic" === e ? t.basicOptions : "http-ftp-sftp" === e ? t.httpFtpSFtpOptions : "http" === e ? t.httpOptions : "ftp-sftp" === e ? t.ftpSFtpOptions : "bt" === e ? t.btOptions : "metalink" === e ? t.metalinkOptions : "rpc" === e ? t.rpcOptions : "advanced" === e && t.advancedOptions
					},
					getaria2QuickSettingsAvailableOptions: function (e) {
						return "globalSpeedLimit" === e && a.globalSpeedLimitOptions
					},
					getAvailableTaskOptionKeys: function (e, t) {
						for (var a = n.taskOptions, i = [], s = 0; s < a.length; s++) {
							var o = a[s],
							r = {
								key: o.key,
								category: o.category
							};
							o.canShow && o.canShow.indexOf(e) < 0 || ("http" === o.category && t || ("bittorrent" !== o.category || t) && (o.canUpdate && o.canUpdate.indexOf(e) < 0 && (r.readonly = !0), i.push(r)))
						}
						return i
					},
					getNewTaskOptionKeys: function () {
						for (var e = n.taskOptions, t = [], a = 0; a < e.length; a++) {
							var i = e[a],
							s = {
								key: i.key,
								category: i.category
							};
							i.canShow && i.canShow.indexOf("new") < 0 || (i.canUpdate && i.canUpdate.indexOf("new") < 0 && (s.readonly = !0), t.push(s))
						}
						return t
					},
					getSpecifiedOptions: function (t, a) {
						var n = [];
						if (!t)
							return n;
						for (var i = 0; i < t.length; i++) {
							var s = t[i],
							o = !1,
							r = null;
							if (angular.isObject(s)) {
								var l = s;
								s = l.key,
								o = !!l.readonly,
								r = l.category
							}
							var c = e[s];
							if (c) {
								if (c = angular.extend({
											key: s,
											nameKey: "options." + s + ".name",
											descriptionKey: "options." + s + ".description"
										}, c), r && (c.category = r), "boolean" === c.type && (c.options = ["true", "false"]), o && (c.readonly = !0), a && a.disableRequired && (c.required = !1), c.options) {
									for (var d = [], u = 0; u < c.options.length; u++)
										d.push({
											name: "options." + c.options[u],
											value: c.options[u]
										});
									c.options = d
								}
								n.push(c)
							}
						}
						return n
					},
					getGlobalOption: function (e, t) {
						return i.getGlobalOption({
							silent: !!t,
							callback: e
						})
					},
					setGlobalOption: function (e, t, a, n) {
						var s = {};
						return s[e] = t,
						i.changeGlobalOption({
							options: s,
							silent: !!n,
							callback: a
						})
					},
					getAria2Status: function (e, t) {
						return i.getVersion({
							silent: !!t,
							callback: e
						})
					},
					getGlobalStat: function (e, t) {
						return i.getGlobalStat({
							silent: !!t,
							callback: function (t) {
								if (!e)
									return void s.warn("[aria2SettingService.getGlobalStat] callback is null");
								var a = o(t);
								e(a)
							}
						})
					},
					saveSession: function (e, t) {
						return i.saveSession({
							silent: !!t,
							callback: e
						})
					},
					shutdown: function (e, t) {
						return i.shutdown({
							silent: !!t,
							callback: e
						})
					}
				}
			}
		])
}
(), angular.module("ariaNg").run(["$templateCache", function (e) {
			e.put("views/list.html", '<section class="content no-padding"><div id="task-table" class="task-table"><div class="task-table-title"><div class="row"><div class="col-md-8 col-sm-7"><div class="row"><div class="col-sm-8"><a ng-click="changeDisplayOrder(\'name:asc\', true)" translate>File Name</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetDisplayOrder(\'name:asc\'), \'fa-sort-desc fa-order-desc\': isSetDisplayOrder(\'name:desc\')}"></i></div><div class="col-sm-4"><a ng-click="changeDisplayOrder(\'size:asc\', true)" translate>File Size</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetDisplayOrder(\'size:asc\'), \'fa-sort-desc fa-order-desc\': isSetDisplayOrder(\'size:desc\')}"></i></div></div></div><div class="col-md-2 col-sm-3"><div class="row"><div class="col-sm-6"><a ng-click="changeDisplayOrder(\'percent:desc\', true)" translate>Progress</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetDisplayOrder(\'percent:asc\'), \'fa-sort-desc fa-order-desc\': isSetDisplayOrder(\'percent:desc\')}"></i></div><div class="col-sm-6"><a ng-click="changeDisplayOrder(\'remain:asc\', true)" translate>Remain Time</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetDisplayOrder(\'remain:asc\'), \'fa-sort-desc fa-order-desc\': isSetDisplayOrder(\'remain:desc\')}"></i></div></div></div><div class="col-md-2 col-sm-2"><a ng-click="changeDisplayOrder(\'dspeed:desc\', true)" translate>Download Speed</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetDisplayOrder(\'dspeed:asc\'), \'fa-sort-desc fa-order-desc\': isSetDisplayOrder(\'dspeed:desc\')}"></i></div></div></div><div class="task-table-body" ng-class="{\'draggable\': isSupportDragTask()}" dragula="\'task-list\'" dragula-model="taskContext.list"><div class="row" ng-repeat="task in taskContext.list | filter: filterByTaskName | taskOrderBy: getOrderType()" data-gid="{{task.gid}}"><div class="col-md-8 col-sm-7 col-xs-12"><div class="checkbox checkbox-primary" ng-class="{\'checkbox-hide\': !taskContext.selected[task.gid]}"><input id="{{\'task_\' + task.gid}}" type="checkbox" ng-model="taskContext.selected[task.gid]"><label for="{{\'task_\' + task.gid}}"><span class="task-name auto-ellipsis" ng-bind="task.taskName" title="{{task.taskName}}"></span></label></div><div class="task-files"><span ng-bind="task.totalLength | readableVolume"></span> <a ng-href="#!/task/detail/{{task.gid}}" title="{{\'Click to view task detail\' | translate}}"><span ng-if="task.files" ng-bind="(\'format.settings.file-count\' | translate: {count: task.selectedFileCount})"></span> </a><i class="icon-error fa fa-times" ng-if="task && task.status == \'error\' && task.errorDescription" title="{{task.errorDescription | translate}}"></i><i class="icon-seeder fa fa-arrow-up" ng-if="task && task.status == \'active\' && task.seeder" title="{{\'Seeding\' | translate}}"></i> <a class="pointer-cursor" ng-if="task && task.status == \'error\' && task.errorDescription && !task.bittorrent" ng-click="restart(task)" title="{{\'Restart\' | translate}}" translate>Restart</a></div></div><div class="col-md-2 col-sm-3 col-xs-12"><div class="progress"><div class="progress-bar" role="progressbar" ng-class="{\'progress-bar-primary\': task.status != \'error\', \'progress-bar-warning\': task.status == \'error\'}" aria-valuenow="{{task.completePercent}}" aria-valuemin="1" aria-valuemax="100" ng-style="{ width: task.completePercent + \'%\' }"><span ng-class="{\'progress-lower\': task.completePercent < 50}" ng-bind="(task.completePercent | percent: 2) + \'%\'"></span></div></div><div><span class="task-last-time" ng-bind="task.status === \'waiting\' ? \'--:--:--\' : (task.status === \'paused\' ? \'\' : (task.status === \'active\' ? ((0 <= task.remainTime && task.remainTime < 86400) ? (task.remainTime | dateDuration: \'second\': \'HH:mm:ss\') : (\'More Than One Day\' | translate)) : \'\'))"></span> <span class="task-download-speed visible-xs-inline pull-right" ng-bind="task.status === \'waiting\' ? (\'Waiting\' | translate) : (task.status === \'paused\' ? (\'Paused\' | translate) : (task.status === \'active\' ? (!task.seeder || task.downloadSpeed > 0 ? (task.downloadSpeed | readableVolume) + \'/s\' : \'-\') : \'\'))"></span> <span class="task-seeders pull-right" ng-bind="task.status === \'active\' ? ((task.numSeeders ? (task.numSeeders + \'/\') : \'\') + task.connections) : \'\'"></span></div></div><div class="col-md-2 col-sm-2 hidden-xs"><span class="task-download-speed" ng-bind="task.status === \'waiting\' ? (\'Waiting\' | translate) : (task.status === \'paused\' ? (\'Paused\' | translate) : (task.status === \'active\' ? (!task.seeder || task.downloadSpeed > 0 ? (task.downloadSpeed | readableVolume) + \'/s\' : \'-\') : \'\'))"></span></div></div></div></div></section>'),
			e.put("views/new.html", '<section class="content no-padding"><form name="newTaskForm" ng-submit="startDownload()" novalidate><div class="nav-tabs-custom"><ul class="nav nav-tabs"><li ng-class="{\'active\': context.currentTab == \'links\'}"><a class="pointer-cursor" ng-click="changeTab(\'links\')" ng-bind="(context.taskType === \'torrent\' ? \'Torrent File\' : (context.taskType === \'metalink\' ? \'Metalink File\' : \'Links\') | translate)">Links</a></li><li ng-class="{\'active\': context.currentTab == \'options\'}"><a class="pointer-cursor" ng-click="changeTab(\'options\')" translate>Options</a></li><li class="divider"></li><li class="nav-toolbar"><div class="btn-group"><button type="button" class="btn btn-sm btn-default dropdown-toggle" data-toggle="dropdown"><i class="fa fa-folder-open-o fa-1_1x"></i></button><ul class="dropdown-menu right-align"><li><a class="pointer-cursor" ng-click="openTorrent()" translate>Open Torrent File</a></li><li><a class="pointer-cursor" ng-click="openMetalink()" translate>Open Metalink File</a></li></ul></div><div class="btn-group"><button type="submit" class="btn btn-sm" ng-class="{\'btn-default\': !context.uploadFile && newTaskForm.$invalid, \'btn-success\': context.uploadFile || !newTaskForm.$invalid}" ng-disabled="!context.uploadFile && newTaskForm.$invalid" translate>Start Download</button>&nbsp; <button type="button" class="btn btn-sm dropdown-toggle" ng-class="{\'btn-default\': !context.uploadFile && newTaskForm.$invalid, \'btn-success\': context.uploadFile || !newTaskForm.$invalid}" ng-disabled="!context.uploadFile && newTaskForm.$invalid" data-toggle="dropdown"><span class="caret"></span></button><ul class="dropdown-menu right-align"><li><a class="pointer-cursor" ng-click="startDownload(true)" translate>Manual Download</a></li></ul></div></li></ul><div class="tab-content no-padding"><div class="tab-pane" ng-class="{\'active\': context.currentTab == \'links\'}"><div class="new-task-table" ng-if="context.taskType === \'urls\'"><div class="row"><div class="col-sm-12"><p translate>Download Links:</p><div class="form-group has-feedback no-margin" ng-class="{ \'has-error\' : newTaskForm.urls.$invalid && newTaskForm.urls.$dirty, \'has-success\' : newTaskForm.urls.$valid && newTaskForm.urls.$dirty }"><textarea name="urls" class="form-control" rows="10" autofocus="autofocus" ng-auto-focus ng-model="context.urls" ng-required="true" ng-keydown="urlTextboxKeyDown($event)" ng-placeholder="\'Support multiple URLs, one URL per line.\' | translate" ng-pattern="/^(\\n?(((http|https|ftp|ssh):\\/\\/.+)|(magnet:\\?.+)))*$/i"></textarea><div class="form-control-icon" ng-if="newTaskForm.urls.$dirty"><i class="fa form-control-feedback" ng-class="{\'fa-check\':newTaskForm.urls.$valid, \'fa-times\':newTaskForm.urls.$invalid}"></i></div></div></div></div></div><div class="new-task-table" ng-if="context.taskType === \'torrent\' || context.taskType === \'metalink\'"><div class="row"><div class="col-sm-12"><p translate>File Name:</p><input class="form-control" ng-value="context.uploadFile ? context.uploadFile.fileName : \'\'" readonly="readonly"></div></div></div></div><div class="tab-pane" ng-class="{\'active\': context.currentTab == \'options\'}"><div class="settings-table striped hoverable"><div class="settings-table-title new-task-filter-title"><div class="row"><div class="col-sm-12"><span translate>Filters</span><span>:&nbsp;</span><div class="checkbox checkbox-inline checkbox-primary"><input id="optionFilterGlobal" type="checkbox" ng-model="context.optionFilter[\'global\']"><label for="optionFilterGlobal" translate>Global</label></div><div class="checkbox checkbox-inline checkbox-primary"><input id="optionFilterHttp" type="checkbox" ng-model="context.optionFilter[\'http\']"><label for="optionFilterHttp" translate>Http</label></div><div class="checkbox checkbox-inline checkbox-primary"><input id="optionFilterBittorrent" type="checkbox" ng-model="context.optionFilter[\'bittorrent\']"><label for="optionFilterBittorrent" translate>BitTorrent</label></div></div></div></div><ng-setting ng-repeat="option in context.availableOptions" ng-if="context.optionFilter[option.category]" option="option" lazy-save-timeout="0" default-value="context.globalOptions[option.key]" on-change-value="setOption(key, value, optionStatus)"></ng-setting></div></div></div></div></form></section>'),
			e.put("views/setting-dialog.html", '<div id="quickSettingModal" class="modal fade" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" ng-bind="(setting ? (setting.title) : \'Quick Settings\') | translate">Quick Setting</h4></div><div class="modal-body overlay-wrapper no-padding"><div class="settings-table striped hoverable"><ng-setting ng-repeat="option in context.availableOptions" option="option" ng-model="context.globalOptions[option.key]" default-value="option.defaultValue" on-change-value="setGlobalOption(key, value, optionStatus)"></ng-setting></div><div class="overlay" ng-if="context.isLoading"><i class="fa fa-refresh fa-spin"></i></div></div><div class="modal-footer"><button type="button" class="btn btn-default" data-dismiss="modal" translate>Cancel</button></div></div>\x3c!-- /.modal-content --\x3e</div>\x3c!-- /.modal-dialog --\x3e</div>\x3c!-- /.modal --\x3e'),
			e.put("views/setting.html", '<div class="row" data-option-key="{{option.key}}"><div class="setting-key setting-key-without-desc col-sm-4"><span ng-bind="option.nameKey | translate"></span> <em ng-bind="\'(\' + option.key + \')\'"></em> <i class="icon-primary fa fa-question-circle" ng-if="(option.descriptionKey | translate) != \'\'" data-toggle="popover" data-trigger="hover" data-placement="auto top" data-container="body" data-content="{{option.descriptionKey | translate}}"></i> <span class="description" ng-if="option.showCount && option.split && optionValue" ng-bind="\'format.settings.total-count\' | translate: {count: getTotalCount()}"></span> <i class="icon-primary fa fa-info-circle" ng-if="(option.since && option.since !== \'\')" ng-tooltip="{{(\'format.requires.aria2-version\' | translate: {version: option.since})}}" ng-tooltip-container="body" ng-tooltip-placement="right"></i></div><div class="setting-value col-sm-8"><div ng-class="{\'input-group\': !!option.suffix}"><div class="form-group has-feedback" ng-class="[optionStatus.getStatusFeedbackStyle()]"><input class="form-control" type="text" placeholder="{{::placeholder}}" ng-disabled="!!option.readonly" ng-if="option.type == \'string\' || option.type == \'integer\' || option.type == \'float\'" ng-model="optionValue" ng-change="changeValue(optionValue, true)"><textarea class="form-control" rows="6" placeholder="{{::placeholder}}" ng-disabled="!!option.readonly" ng-if="option.type == \'text\'" ng-model="optionValue" ng-change="changeValue(optionValue, true)"></textarea><select class="form-control" style="width: 100%" ng-disabled="!!option.readonly" ng-class="{\'placeholder\': !optionValue}" ng-if="option.type == \'boolean\' || option.type == \'option\'" ng-model="optionValue" ng-change="changeValue(optionValue, false)" ng-options="item.value as (item.name | translate) for item in option.options"><option value="" disabled="disabled" ng-bind="(placeholder | translate)" style="display: none"></option></select><div class="form-control-icon" ng-if="optionStatus.isShowStatusIcon()"><i class="fa form-control-feedback" ng-class="[optionStatus.getStatusIcon()]"></i></div></div><span class="input-group-addon" ng-if="!!option.suffix" ng-bind="option.suffix | translate"></span></div></div></div>'),
			e.put("views/settings-aria2.html", '<section class="content no-padding"><div class="settings-table striped hoverable"><ng-setting ng-repeat="option in context.availableOptions" option="option" ng-model="context.globalOptions[option.key]" default-value="option.defaultValue" on-change-value="setGlobalOption(key, value, optionStatus)"></ng-setting></div></section>'),
			e.put("views/settings-ariang.html", '<section class="content no-padding"><div class="nav-tabs-custom"><ul class="nav nav-tabs"><li ng-class="{\'active\': isCurrentGlobalTab()}"><a class="pointer-cursor" ng-click="changeGlobalTab()" translate>Global</a></li><li class="nav-tab-title-rpcname" ng-repeat="setting in context.rpcSettings" ng-class="{\'active\': isCurrentRpcTab($index)}"><a class="pointer-cursor" ng-click="changeRpcTab($index)"><span class="nav-tab-rpcname" ng-bind="\'RPC\' + (setting.rpcAlias || setting.rpcHost ? \' (\' + (setting.rpcAlias ? setting.rpcAlias : setting.rpcHost + \':\' + setting.rpcPort) + \')\' : \'\')" title="{{(setting.rpcAlias ? setting.rpcAlias : setting.rpcHost + \':\' + setting.rpcPort)}}">RPC</span> </a><a class="pointer-cursor nav-tab-close" ng-if="!setting.isDefault" title="{{\'Delete RPC Setting\' | translate}}"><i class="fa fa-times" ng-click="removeRpcSetting(setting)"></i></a></li><li class="slim"><a class="pointer-cursor" ng-click="addNewRpcSetting()" title="{{\'Add New RPC Setting\' | translate}}"><i class="fa fa-plus"></i></a></li></ul><div class="tab-content no-padding"><div class="tab-pane" ng-class="{\'active\': isCurrentGlobalTab()}"><div class="settings-table striped hoverable"><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Language</span></div><div class="setting-value col-sm-8"><select class="form-control" style="width: 100%" ng-model="context.settings.language" ng-options="type as language.displayName for (type, language) in context.languages" ng-change="setLanguage(context.settings.language)"></select></div></div><div class="row" ng-if="context.showDebugMode"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Debug Mode</span></div><div class="setting-value col-sm-8"><select class="form-control" style="width: 100%" ng-model="context.sessionSettings.debugMode" ng-options="option.value as (option.name | translate) for option in context.trueFalseOptions" ng-change="setDebugMode(context.sessionSettings.debugMode)"></select></div></div><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Page Title</span> <i class="icon-primary fa fa-question-circle" data-toggle="popover" data-trigger="hover" data-placement="auto right" data-container="body" data-html="true" data-content="{{(\'Supported Placeholder\' | translate) + \':<br/>\' +\n                               (\'AriaNg Title\' | translate) + \': ${title}<br/>\' +\n                               (\'Downloading Count\' | translate) + \': ${downloading}<br/>\' +\n                                (\'Waiting Count\' | translate) + \': ${waiting}<br/>\' +\n                                (\'Stopped Count\' | translate) + \': ${stopped}<br/>\' +\n                                (\'Download Speed\' | translate) + \': ${downspeed}<br/>\' +\n                                (\'Upload Speed\' | translate) + \': ${upspeed}<br/><br/>\' +\n                                (\'Tips: You can use the &quot;noprefix&quot; tag to ignore the prefix, &quot;nosuffix&quot; tag ignore the suffix, and &quot;scale=n&quot; tag to set the decimal precision.\' | translate) + \'<br/>\' +\n                                (\'Example: ${downspeed:noprefix:nosuffix:scale=1}\' | translate)}}"></i></div><div class="setting-value col-sm-8"><input class="form-control" type="text" ng-model="context.settings.title" ng-change="setTitle(context.settings.title); updateTitlePreview()"> <em>[<span translate>Preview</span>] <span ng-bind="context.titlePreview"></span></em></div></div><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Page Title Refresh Interval</span> <span class="asterisk">*</span></div><div class="setting-value col-sm-8"><select class="form-control" style="width: 100%" ng-model="context.settings.titleRefreshInterval" ng-change="setTitleRefreshInterval(context.settings.titleRefreshInterval)" ng-options="time.optionValue as (time.name | translate: {value: time.value}) for time in context.availableTime"></select></div></div><div class="row" ng-if="isSupportNotification()"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Enable Browser Notification</span></div><div class="setting-value col-sm-8"><select class="form-control" style="width: 100%" ng-model="context.settings.browserNotification" ng-change="setEnableBrowserNotification(context.settings.browserNotification)" ng-options="option.value as (option.name | translate) for option in context.trueFalseOptions"></select></div></div><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Global Stat Refresh Interval</span> <span class="asterisk">*</span></div><div class="setting-value col-sm-8"><select class="form-control" style="width: 100%" ng-model="context.settings.globalStatRefreshInterval" ng-change="setGlobalStatRefreshInterval(context.settings.globalStatRefreshInterval)" ng-options="time.optionValue as (time.name | translate: {value: time.value}) for time in context.availableTime"></select></div></div><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Download Task Refresh Interval</span> <span class="asterisk">*</span></div><div class="setting-value col-sm-8"><select class="form-control" style="width: 100%" ng-model="context.settings.downloadTaskRefreshInterval" ng-change="setDownloadTaskRefreshInterval(context.settings.downloadTaskRefreshInterval)" ng-options="time.optionValue as (time.name | translate: {value: time.value}) for time in context.availableTime"></select></div></div><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Action After Creating New Tasks</span></div><div class="setting-value col-sm-8"><select class="form-control" style="width: 100%" ng-model="context.settings.afterCreatingNewTask" ng-change="setAfterCreatingNewTask(context.settings.afterCreatingNewTask)"><option value="task-list" translate>Navigate to Task List Page</option><option value="task-detail" translate>Navigate to Task Detail Page</option></select></div></div><div class="row tip no-background no-hover"><span class="asterisk">*</span> <span translate>Changes to the settings take effect after refreshing page.</span></div></div></div><div class="tab-pane" ng-repeat="setting in context.rpcSettings" ng-class="{\'active\': isCurrentRpcTab($index)}"><div class="settings-table striped hoverable"><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Aria2 RPC Alias</span> <span class="asterisk">*</span></div><div class="setting-value col-sm-8"><input class="form-control" type="text" ng-placeholder="(setting.rpcHost ? setting.rpcHost + \':\' + setting.rpcPort : \'\')" ng-model="setting.rpcAlias" ng-change="updateRpcSetting(setting, \'rpcAlias\')"></div></div><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Aria2 RPC Address</span> <span class="asterisk">*</span></div><div class="setting-value col-sm-8"><div class="input-group input-group-multiple"><span class="input-group-addon" ng-bind="setting.protocol + \'://\'"></span> <input class="form-control" type="text" ng-model="setting.rpcHost" ng-change="updateRpcSetting(setting, \'rpcHost\')"> <span class="input-group-addon">:</span><div class="input-grougp-addon-container"><input class="form-control form-control-rpcport" type="text" ng-model="setting.rpcPort" ng-change="updateRpcSetting(setting, \'rpcPort\')"></div><span class="input-group-addon">/</span><div class="input-grougp-addon-container"><input class="form-control form-control-rpcinterface" type="text" ng-model="setting.rpcInterface" ng-change="updateRpcSetting(setting, \'rpcInterface\')"></div></div></div></div><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Aria2 RPC Protocol</span> <span class="asterisk">*</span></div><div class="setting-value col-sm-8"><select class="form-control" style="width: 100%" ng-model="setting.protocol" ng-change="updateRpcSetting(setting, \'protocol\')"><option value="http" translate>Http</option><option value="https" translate>Https</option><option value="ws" translate>WebSocket</option><option value="wss" translate>WebSocket (Security)</option></select></div></div><div class="row" ng-if="setting.protocol === \'http\' || setting.protocol === \'https\'"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Aria2 RPC Http Request Method</span> <span class="asterisk">*</span> <i class="icon-primary fa fa-question-circle" ng-tooltip-container="body" ng-tooltip-placement="top" ng-tooltip="{{\'POST method only supports aria2 v1.15.2 and above.\' | translate}}"></i></div><div class="setting-value col-sm-8"><select class="form-control" style="width: 100%" ng-model="setting.httpMethod" ng-change="updateRpcSetting(setting, \'httpMethod\')"><option value="POST" translate>POST</option><option value="GET" translate>GET</option></select></div></div><div class="row"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Aria2 RPC Secret Token</span> <span class="asterisk">*</span></div><div class="setting-value col-sm-8"><div class="input-group"><input class="form-control" type="{{context.showRpcSecret ? \'text\' : \'password\'}}" ng-model="setting.secret" ng-change="updateRpcSetting(setting, \'secret\')"> <span class="input-group-addon input-group-addon-compact no-vertical-padding"><button class="btn btn-xs btn-default" title="{{context.showRpcSecret ? \'Hide Secret\' : \'Show Secret\' | translate}}" ng-class="{\'active\': context.showRpcSecret}" ng-click="context.showRpcSecret = !context.showRpcSecret"><i class="fa fa-eye"></i></button></span></div></div></div><div class="row tip no-background no-hover"><span class="asterisk">*</span> <span translate>Changes to the settings take effect after refreshing page.</span> <button class="btn btn-xs btn-default" ng-disabled="setting.isDefault" ng-click="setDefaultRpcSetting(setting)"><span translate>Activate</span></button></div></div></div></div></div></section><script id="setting-changed-notification.html" type="text/ng-template"><div class="ui-notification custom-template">\n        <div class="message" ng-bind-html="message"></div>\n        <div class="message">\n            <a class="btn btn-small btn-primary close-notification" ng-click="refreshPage()" translate>Reload Page</a>\n        </div>\n    </div><\/script>'),
			e.put("views/status.html", '<section class="content no-padding"><div class="settings-table striped hoverable"><div class="row"><div class="setting-key col-sm-4"><span translate>Aria2 RPC Address</span></div><div class="setting-value col-sm-8"><span ng-bind="context.host"></span></div></div><div class="row"><div class="setting-key col-sm-4"><span translate>Aria2 Status</span></div><div class="setting-value col-sm-8"><span class="label" ng-class="{\'label-primary\': context.status === \'Connecting\', \'label-success\': context.status === \'Connected\', \'label-danger\': context.status === \'Not Connected\'}" ng-bind="context.status | translate"></span></div></div><div class="row ng-cloak" ng-if="context.serverStatus"><div class="setting-key col-sm-4"><span translate>Aria2 Version</span></div><div class="setting-value col-sm-8"><span ng-bind="context.serverStatus.version"></span></div></div><div class="row ng-cloak" ng-if="context.serverStatus"><div class="setting-key col-sm-4"><span translate>Enabled Features</span></div><div class="setting-value col-sm-8"><div class="checkbox checkbox-primary checkbox-compact default-cursor" ng-repeat="feature in context.serverStatus.enabledFeatures"><input id="{{\'feature_\' + $index}}" type="checkbox" checked="checked" disabled="disabled" class="default-cursor"><label for="{{\'feature_\' + $index}}" class="text-cursor"><span ng-bind="feature"></span></label></div></div></div><div class="row ng-cloak" ng-if="context.serverStatus"><div class="setting-key setting-key-without-desc col-sm-4"><span translate>Functions</span></div><div class="setting-value col-sm-8"><button class="btn btn-sm btn-primary" ng-click="saveSession()" promise-btn><span translate>Save Session</span></button> <button class="btn btn-sm btn-danger" ng-click="shutdown()"><span translate>Shutdown Aria2</span></button></div></div></div></section>'),
			e.put("views/task-detail.html", '<section class="content no-padding" ng-if="task"><div class="nav-tabs-custom"><ul class="nav nav-tabs"><li ng-class="{\'active\': context.currentTab == \'overview\'}"><a class="pointer-cursor" ng-click="changeTab(\'overview\')" translate>Overview</a></li><li ng-class="{\'active\': context.currentTab == \'blocks\'}"><a class="pointer-cursor" ng-click="changeTab(\'blocks\')" translate>Blocks</a></li><li ng-class="{\'active\': context.currentTab == \'filelist\'}"><a class="pointer-cursor" ng-click="changeTab(\'filelist\')" translate>Files</a></li><li ng-class="{\'active\': context.currentTab == \'btpeers\'}" ng-if="task && task.status == \'active\' && task.bittorrent"><a class="pointer-cursor" ng-click="changeTab(\'btpeers\')" translate>Peers</a></li><li ng-class="{\'active\': context.currentTab == \'settings\'}" ng-if="task && (task.status == \'active\' || task.status == \'waiting\' || task.status == \'paused\')" class="slim"><a class="pointer-cursor" ng-click="changeTab(\'settings\')"><i class="fa fa-gear"></i></a></li></ul><div class="tab-content no-padding"><div class="tab-pane" ng-class="{\'active\': context.currentTab == \'overview\'}"><div class="settings-table striped hoverable"><div class="row" ng-if="task"><div class="setting-key col-sm-4"><span translate>Task Name</span></div><div class="setting-value col-sm-8"><span class="allow-word-break" ng-bind="task.taskName"></span></div></div><div class="row" ng-if="task"><div class="setting-key col-sm-4"><span translate>Task Size</span></div><div class="setting-value col-sm-8"><span ng-bind="task.totalLength | readableVolume"></span> <a class="pointer-cursor" ng-if="task.files" ng-click="changeTab(\'filelist\')"><span ng-bind="(\'format.settings.file-count\' | translate: {count: task.selectedFileCount})"></span></a></div></div><div class="row" ng-if="task"><div class="setting-key col-sm-4"><span translate>Task Status</span></div><div class="setting-value col-sm-8"><span ng-bind="task | taskStatus | translate: {errorcode: task.errorCode}"></span> <i class="icon-primary fa fa-question-circle" ng-if="task.errorCode && task.errorCode != \'0\' && task.errorMessage" ng-tooltip="{{task.errorMessage}}" ng-tooltip-container="body" ng-tooltip-placement="top"></i></div></div><div class="row" ng-if="task && task.status == \'error\' && task.errorDescription"><div class="setting-key col-sm-4"><span translate>Error Description</span></div><div class="setting-value col-sm-8"><span ng-bind="task.errorDescription | translate"></span></div></div><div class="row" ng-if="task"><div class="setting-key col-sm-4"><span ng-bind="(\'Progress\' | translate) + (task.status == \'active\' && task.bittorrent ? \' (\' + (\'Health Percentage\' | translate) + \')\' : \'\')"></span></div><div class="setting-value col-sm-8"><span ng-bind="(task.completePercent | percent: 2) + \'%\' + (task.status == \'active\' && task.bittorrent ? \' (\' + (context.healthPercent | percent: 2) + \'%\' + \')\' : \'\')"></span></div></div><div class="row" ng-if="task"><div class="setting-key col-sm-4"><span translate>Download</span></div><div class="setting-value col-sm-8"><span ng-bind="(task.completedLength | readableVolume) + (task.status == \'active\' ? \' @ \' + (task.downloadSpeed | readableVolume) + \'/s\' : \'\')"></span></div></div><div class="row" ng-if="task && task.bittorrent"><div class="setting-key col-sm-4"><span translate>Upload</span></div><div class="setting-value col-sm-8"><span ng-bind="(task.uploadLength | readableVolume) + (task.status == \'active\' ? \' @ \' + (task.uploadSpeed | readableVolume) + \'/s\' : \'\')"></span></div></div><div class="row" ng-if="task && task.bittorrent"><div class="setting-key col-sm-4"><span translate>Share Ratio</span></div><div class="setting-value col-sm-8"><span ng-bind="(task.shareRatio | number: 2)"></span></div></div><div class="row" ng-if="task && task.status == \'active\' && task.completedLength < task.totalLength"><div class="setting-key col-sm-4"><span translate>Remain Time</span></div><div class="setting-value col-sm-8"><span ng-bind="0 <= task.remainTime && task.remainTime < 86400? (task.remainTime | dateDuration: \'second\': \'HH:mm:ss\') : (\'More Than One Day\' | translate)"></span></div></div><div class="row" ng-if="task && task.status == \'active\'"><div class="setting-key col-sm-4"><span ng-bind="(task.bittorrent ? (\'Seeders\' | translate) + \' / \' : \'\') + (\'Connections\' | translate)">Connections</span></div><div class="setting-value col-sm-8"><span ng-bind="(task.numSeeders ? (task.numSeeders + \' / \') : \'\') + task.connections"></span></div></div><div class="row" ng-if="task && task.bittorrent && task.bittorrent.creationDate"><div class="setting-key col-sm-4"><span translate>Seed Creation Time</span></div><div class="setting-value col-sm-8"><span ng-bind="task.bittorrent.creationDate | amFromUnix | longDate"></span></div></div><div class="row" ng-if="task && task.infoHash"><div class="setting-key col-sm-4"><span translate>Info Hash</span></div><div class="setting-value col-sm-8"><span class="allow-word-break" ng-bind="task.infoHash"></span></div></div><div class="row" ng-if="task"><div class="setting-key col-sm-4"><span translate>Download Dir</span></div><div class="setting-value col-sm-8"><span class="allow-word-break" ng-bind="task.dir"></span></div></div><div class="row" ng-if="task && task.bittorrent && task.bittorrent.announceList && task.bittorrent.announceList.length > 0"><div class="setting-key col-sm-4"><span translate>BT Tracker Servers</span> <span class="description-inline" ng-bind="\'format.settings.total-count\' | translate: {count: task.bittorrent.announceList.length}"></span> <i class="icon-expand pointer-cursor fa" ng-if="task.bittorrent.announceList.length > 1" ng-class="{\'fa-plus\': context.collapseTrackers, \'fa-minus\': !context.collapseTrackers}" ng-click="context.collapseTrackers = !context.collapseTrackers" title="{{(context.collapseTrackers ? \'Expand\' : \'Collapse\') | translate}}"></i></div><div class="setting-value col-sm-8"><div class="auto-ellipsis" ng-bind="serverAddress" title="{{serverAddress}}" ng-repeat="serverAddress in task.bittorrent.announceList | limitTo: (context.collapseTrackers ? 1 : task.bittorrent.announceList.length)"></div></div></div><div class="row no-hover no-background" ng-if="context.isEnableSpeedChart && task && task.status == \'active\'"><div class="col-sm-12"><div class="task-status-chart-wrapper"><ng-chart ng-data="context.statusData" height="200"></ng-chart></div></div></div></div></div><div class="tab-pane" ng-class="{\'active\': context.currentTab == \'blocks\'}"><div class="piece-legends"><div class="piece-legend" title="{{(\'format.task.pieceinfo\' | translate: {completed: task.completedPieces, total: task.numPieces})}}"><div class="piece piece-completed"></div><span translate>Completed</span></div><div class="piece-legend" title="{{(\'format.task.pieceinfo\' | translate: {completed: task.completedPieces, total: task.numPieces})}}"><div class="piece"></div><span translate>Uncompleted</span></div></div><ng-piece-map bit-field="task.bitfield" piece-count="task.numPieces"></ng-piece-map></div><div class="tab-pane" ng-class="{\'active\': context.currentTab == \'filelist\'}"><div class="task-table"><div class="task-table-title"><div class="row"><div class="col-sm-8"><a ng-click="changeFileListDisplayOrder(\'name:asc\', true)" translate>File Name</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetFileListDisplayOrder(\'name:asc\'), \'fa-sort-desc fa-order-desc\': isSetFileListDisplayOrder(\'name:desc\')}"></i> <a ng-click="showChooseFilesToolbar()" ng-if="task && task.files && task.files.length > 1 && (task.status == \'waiting\' || task.status == \'paused\')" translate>(Choose Files)</a></div><div class="col-sm-2"><a ng-click="changeFileListDisplayOrder(\'percent:desc\', true)" translate>Progress</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetFileListDisplayOrder(\'percent:asc\'), \'fa-sort-desc fa-order-desc\': isSetFileListDisplayOrder(\'percent:desc\')}"></i></div><div class="col-sm-2"><a ng-click="changeFileListDisplayOrder(\'size:asc\', true)" translate>File Size</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetFileListDisplayOrder(\'size:asc\'), \'fa-sort-desc fa-order-desc\': isSetFileListDisplayOrder(\'size:desc\')}"></i></div></div></div><div class="task-table-title" ng-if="context.showChooseFilesToolbar"><div class="row"><div class="col-sm-12"><button class="btn btn-xs btn-primary" ng-click="selectFiles(\'all\')" translate>Select All</button> <button class="btn btn-xs btn-primary" ng-click="selectFiles(\'none\')" translate>Select None</button> <button class="btn btn-xs btn-primary" ng-click="selectFiles(\'reverse\')" translate>Select Invert</button> <button class="btn btn-xs btn-default" ng-click="chooseSpecifiedFiles(\'video\')"><i class="fa fa-file-video-o"></i> <span translate>Videos</span></button> <button class="btn btn-xs btn-default" ng-click="chooseSpecifiedFiles(\'audio\')"><i class="fa fa-file-audio-o"></i> <span translate>Audios</span></button> <button class="btn btn-xs btn-default" ng-click="chooseSpecifiedFiles(\'picture\')"><i class="fa fa-file-picture-o"></i> <span translate>Pictures</span></button> <button class="btn btn-xs btn-default" ng-click="chooseSpecifiedFiles(\'document\')"><i class="fa fa-file-text-o"></i> <span translate>Documents</span></button> <button class="btn btn-xs btn-default" ng-click="chooseSpecifiedFiles(\'application\')"><i class="fa fa-file-o"></i> <span translate>Applications</span></button> <button class="btn btn-xs btn-default" ng-click="chooseSpecifiedFiles(\'archive\')"><i class="fa fa-file-archive-o"></i> <span translate>Archives</span></button> <button class="btn btn-xs btn-success" ng-click="saveChoosedFiles()" ng-disabled="getSelectedFileCount() < 1" translate>Confirm</button> <button class="btn btn-xs btn-default" ng-click="cancelChooseFiles()" translate>Cancel</button></div></div></div><div class="task-table-body"><div class="row" ng-repeat="file in task.files | fileOrderBy: getFileListOrderType()" data-file-index="{{file.index}}"><div class="col-sm-8"><div class="checkbox checkbox-primary"><input id="{{\'file_\' + file.index}}" type="checkbox" ng-disabled="!task || !task.files || task.files.length < 2 || (task.status != \'waiting\' && task.status != \'paused\')" ng-model="file.selected" ng-change="setSelectedFile()"><label for="{{\'file_\' + file.index}}" class="allow-word-break" ng-bind="file.fileName" title="{{file.fileName}}"></label></div></div><div class="col-sm-2"><div class="progress"><div class="progress-bar progress-bar-primary" role="progressbar" aria-valuenow="{{file.completePercent}}" aria-valuemin="1" aria-valuemax="100" ng-style="{ width: file.completePercent + \'%\' }"><span ng-class="{\'progress-lower\': file.completePercent < 50}" ng-bind="(file.completePercent | percent: 2) + \'%\'"></span></div></div></div><div class="col-sm-2"><span class="task-size" ng-bind="file.length | readableVolume"></span></div></div></div></div></div><div class="tab-pane" ng-class="{\'active\': context.currentTab == \'btpeers\'}" ng-if="task && task.status == \'active\' && task.bittorrent"><div class="task-table"><div class="task-table-title"><div class="row"><div class="col-md-4 col-sm-4"><a ng-click="changePeerListDisplayOrder(\'address:asc\', true)" translate>Address</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetPeerListDisplayOrder(\'address:asc\'), \'fa-sort-desc fa-order-desc\': isSetPeerListDisplayOrder(\'address:desc\')}"></i> <span>/</span> <a ng-click="changePeerListDisplayOrder(\'client:asc\', true)" translate>Client</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetPeerListDisplayOrder(\'client:asc\'), \'fa-sort-desc fa-order-desc\': isSetPeerListDisplayOrder(\'client:desc\')}"></i></div><div class="col-md-5 col-sm-4"><div class="row"><div class="col-sm-6"><span translate>Status</span></div><div class="col-sm-6 text-right"><a ng-click="changePeerListDisplayOrder(\'percent:desc\', true)" translate>Progress</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetPeerListDisplayOrder(\'percent:asc\'), \'fa-sort-desc fa-order-desc\': isSetPeerListDisplayOrder(\'percent:desc\')}"></i></div></div></div><div class="col-md-3 col-sm-4"><a ng-click="changePeerListDisplayOrder(\'dspeed:desc\', true)" translate>Download</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetPeerListDisplayOrder(\'dspeed:asc\'), \'fa-sort-desc fa-order-desc\': isSetPeerListDisplayOrder(\'dspeed:desc\')}"></i> <span>/</span> <a ng-click="changePeerListDisplayOrder(\'uspeed:desc\', true)" translate>Upload</a> <i class="fa" ng-class="{\'fa-sort-asc fa-order-asc\': isSetPeerListDisplayOrder(\'uspeed:asc\'), \'fa-sort-desc fa-order-desc\': isSetPeerListDisplayOrder(\'uspeed:desc\')}"></i> <span translate>Speed</span></div></div></div><div class="task-table-body"><div class="row" ng-repeat="peer in context.btPeers | peerOrderBy: getPeerListOrderType()"><div class="col-md-4 col-sm-4 col-xs-12"><div class="peer-name-wrapper auto-ellipsis" title="{{(peer.client ? peer.client.info : \'\') + (peer.seeder ? (peer.client.info ? \', \' : \'\') + (\'Seeding\' | translate) : \'\')}}"><span ng-bind="peer.name | translate"></span><i class="icon-seeder fa fa-angle-double-up" ng-if="peer && peer.seeder"></i> <span class="peer-client" ng-if="!!peer.client" ng-bind="peer.client ? (\'(\' + peer.client.name + (peer.client.version ? \' \' + peer.client.version : \'\') + \')\') : \'\'"></span></div></div><div class="col-md-5 col-sm-4 col-xs-12"><div class="row"><div class="col-md-9 col-sm-7 col-xs-12"><div class="piece-bar-wrapper"><ng-piece-bar bit-field="peer.bitfield" piece-count="task.numPieces" color="#208fe5"></ng-piece-bar></div></div><div class="col-md-3 col-sm-5 hidden-xs text-right"><span ng-bind="(peer.completePercent | percent: 2) + \'%\'"></span></div></div></div><div class="visible-xs col-xs-4"><span ng-bind="(peer.completePercent | percent: 2) + \'%\'"></span></div><div class="col-md-3 col-sm-4 col-xs-8"><div class="task-peer-download-speed"><i class="icon-download fa fa-arrow-down"></i> <span ng-bind="(peer.downloadSpeed | readableVolume) + \'/s\'"></span>&nbsp; <i class="icon-upload fa fa-arrow-up"></i> <span ng-bind="(peer.uploadSpeed | readableVolume) + \'/s\'"></span></div></div></div><div class="row" ng-if="!context.btPeers || context.btPeers.length < 1"><div class="col-sm-12 text-center"><span translate>No connected peers</span></div></div></div></div></div><div class="tab-pane" ng-class="{\'active\': context.currentTab == \'settings\'}" ng-if="task && (task.status == \'active\' || task.status == \'waiting\' || task.status == \'paused\')"><div class="settings-table striped hoverable"><ng-setting ng-repeat="option in context.availableOptions" option="option" ng-model="context.options[option.key]" default-value="option.defaultValue" on-change-value="setOption(key, value, optionStatus)"></ng-setting></div></div></div></div>\x3c!-- /.nav-tabs-custom --\x3e</section>')
		}
	]);
